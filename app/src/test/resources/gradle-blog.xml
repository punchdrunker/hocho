<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" media="screen" href="/~files/atom-premium.xsl"?>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:feedpress="https://feed.press/xmlns">
  <feedpress:locale>en</feedpress:locale>
  <link rel="hub" href="http://feedpress.superfeedr.com/"/>
  <logo>https://static.feedpress.it/logo/gradle-57dff1a6c256f.png</logo>
  <title>The Gradle Blog</title>
  <link rel="alternate" type="text/html" href="https://blog.gradle.org"/>
  <link rel="self" type="application/atom+xml" href="http://feed.gradle.org/blog.atom"/>
  <updated>2018-01-12T15:14:55+00:00</updated>
  <id>https://blog.gradle.org/</id>
  <entry>
    <title>Introducing the new C++ plugins</title>
    <link href="https://blog.gradle.org/introducing-the-new-cpp-plugins"/>
    <updated>2018-01-10T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/introducing-the-new-cpp-plugins</id>
    <author>
      <name>Adam Murdoch</name>
    </author>
    <content type="html">
      &lt;p&gt;This post introduces some new plugins for C++ that we’ve been working on. These plugins can build C++ libraries and applications. They work on macOS, Linux, and Windows with GCC, Clang and Visual C++/Visual Studio.&lt;/p&gt;

&lt;p&gt;The plugins will eventually replace the software model plugins and take advantage of many new features baked into Gradle core, such as a rich dependency management engine, &lt;a href="https://blog.gradle.org/introducing-gradle-build-cache"&gt;build cache&lt;/a&gt;, &lt;a href="https://blog.gradle.org/introducing-composite-builds"&gt;composite builds&lt;/a&gt;, &lt;a href="https://guides.gradle.org/using-the-worker-api/"&gt;finer grained parallel execution&lt;/a&gt;, &lt;a href="https://gradle.com/build-scans"&gt;build scans&lt;/a&gt;, and more. For background, see our post on the &lt;a href="https://blog.gradle.org/state-and-future-of-the-gradle-software-model"&gt;State and Future of the Gradle Software Model&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We welcome any feedback you may have about these plugins. You can leave feedback on the &lt;a href="https://discuss.gradle.org/"&gt;Gradle forums&lt;/a&gt; or raise issues on the &lt;a href="https://github.com/gradle/gradle-native"&gt;Gradle native&lt;/a&gt; GitHub repository.&lt;/p&gt;

&lt;h2 id="building-an-application"&gt;Building an application&lt;/h2&gt;

&lt;p&gt;You can find all of the samples from this post in the &lt;a href="https://github.com/gradle/native-samples"&gt;Gradle native samples&lt;/a&gt; GitHub repository. Let’s look at building a &lt;a href="https://github.com/gradle/native-samples/tree/master/cpp/application"&gt;simple application&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The build script should look familiar to anyone who has used Gradle’s Java plugins:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;plugins&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="s1"&gt;'cpp-application'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This application has no dependencies, and the C++ source files and headers live in the default location: the &lt;code class="highlighter-rouge"&gt;src/main/cpp&lt;/code&gt; directory. Since this is Gradle, you can easily configure the source locations to match whatever layout your project has, including the common pattern of putting everything in one directory.&lt;/p&gt;

&lt;p&gt;Here’s the result of running &lt;code class="highlighter-rouge"&gt;./gradlew assemble&lt;/code&gt; on this sample:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/01-application.gif" alt="./gradlew assemble" /&gt;&lt;/p&gt;

&lt;p&gt;Take a look at the build scan for this build to see what happened in more detail.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://scans.gradle.com/s/2fwbsmwmrvlqi/timeline"&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/compile-debug-cpp-timeline.png" alt="compile debug timeline" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The plugins automatically find the compiler, linker and other tools to build the application. The result ends up installed in the &lt;code class="highlighter-rouge"&gt;build/install&lt;/code&gt; directory ready to run.&lt;/p&gt;

&lt;h2 id="ide-support"&gt;IDE support&lt;/h2&gt;

&lt;p&gt;Xcode is currently supported for C++ projects. You can just run &lt;code class="highlighter-rouge"&gt;./gradlew xcode&lt;/code&gt; and open the generated workspace. Support for generating Visual Studio solutions will be added early this year and support for other IDEs will be gradually added after that.&lt;/p&gt;

&lt;p&gt;Here is the result of running &lt;code class="highlighter-rouge"&gt;./gradlew xcode&lt;/code&gt; on the sample:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/02-xcode.gif" alt="./gradlew xcode" /&gt;&lt;/p&gt;

&lt;p&gt;This is how the workspace looks in Xcode:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/02-xcode-ide.png" alt="Xcode integration" /&gt;&lt;/p&gt;

&lt;h2 id="dependencies"&gt;Dependencies&lt;/h2&gt;

&lt;p&gt;The plugin uses Gradle’s &lt;a href="https://docs.gradle.org/current/userguide/artifact_dependencies_tutorial.html"&gt;dependency management&lt;/a&gt; features, just like other plugins such as the Java or Android plugins. This means, for example, transitive dependencies work just fine.&lt;/p&gt;

&lt;p&gt;Let’s add a dependency on a library to the application. In &lt;a href="https://github.com/gradle/native-samples/tree/master/cpp/binary-dependencies"&gt;this sample&lt;/a&gt;, the C++ library is downloaded from a Maven repository. You don’t have to install the library anywhere manually, and everyone who runs the build will use the version specified in the build script, rather than whatever version happens to be installed on their machine.&lt;/p&gt;

&lt;p&gt;The build script defines a Maven repository and declares a dependency on another sample C++ library:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;repositories&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;maven&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// In this sample, we used a local Maven repository, &lt;/span&gt;
        &lt;span class="c1"&gt;// but Maven Central or Artifactory server can be used.&lt;/span&gt;
        &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="s1"&gt;'http://localhost:8000/'&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;dependencies&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;implementation&lt;/span&gt; &lt;span class="s1"&gt;'org.gradle.cpp-samples:math:1.5'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is the result of running &lt;code class="highlighter-rouge"&gt;./gradlew assemble&lt;/code&gt;. Gradle downloads the headers and shared library binary and compiles and links against these:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/03-dependency-management.gif" alt="./gradlew assemble" /&gt;&lt;/p&gt;

&lt;p&gt;The build scan shows more detail, including the downloads.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://scans.gradle.com/s/lglez2sq5zcik/performance/networkActivity"&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/cpp-assemble-network.png" alt="app assemble build scan network activity" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here is how this project looks in Xcode:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/03-xcode-ide.png" alt="Xcode integration" /&gt;&lt;/p&gt;

&lt;h2 id="tests"&gt;Tests&lt;/h2&gt;

&lt;p&gt;Basic unit testing is supported out of the box. Here is a &lt;a href="https://github.com/gradle/native-samples/tree/master/cpp/simple-library"&gt;sample that uses Google Test&lt;/a&gt;, downloaded from a Maven repository. We published the binaries using this &lt;a href="https://github.com/gradle/googletest"&gt;fork&lt;/a&gt; of Google Test, which simply adds a Gradle build.&lt;/p&gt;

&lt;p&gt;The build script declares a dependency on Google test and a Maven repository that can be used to locate the Google test binaries:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;plugins&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="s1"&gt;'cpp-unit-test'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;repositories&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;maven&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="s1"&gt;'https://repo.gradle.org/gradle/libs-snapshots-local/'&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;dependencies&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Currently we have to encode the operating system and architecture in &lt;/span&gt;
    &lt;span class="c1"&gt;// the dependency name. This will disappear in later releases&lt;/span&gt;
    &lt;span class="n"&gt;unitTestImplementation&lt;/span&gt; &lt;span class="s1"&gt;'org.gradle.cpp-samples:googletest_macosx_x86-64_4.5:1.9.0-SNAPSHOT'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is the result of running &lt;code class="highlighter-rouge"&gt;./gradlew check&lt;/code&gt;. Gradle downloads the Google test library, compiles the C++ source and tests and then runs the tests:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/04-google-test.gif" alt="./gradlew check" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://gradle.com/s/ox73aii7ieebi"&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/cpp-google-test.png" alt="build scan for math check" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Richer reporting, build scan support, parallel execution and filtering for Google Test will be added this year with support for other C++ testing frameworks after that.&lt;/p&gt;

&lt;h2 id="fast-builds"&gt;Fast builds&lt;/h2&gt;

&lt;p&gt;The plugins can produce debug and release builds of the application or library using Gradle’s new variant-aware dependency management, so that debug builds are compiled and linked against debug library binaries, and release builds are compiled and linked against release library binaries. When you build the debug build, which is the default, Gradle builds &lt;em&gt;only&lt;/em&gt; the debug builds of the libraries that you need, rather than building everything.&lt;/p&gt;

&lt;p&gt;Developer and CI builds are fast. C++ compilation is a cacheable task, so you can avoid unnecessary and long compilation times when using the &lt;a href="https://docs.gradle.org/current/userguide/build_cache.html"&gt;build cache&lt;/a&gt;. &lt;a href="https://gradle.com/build-cache"&gt;Gradle Enterprise&lt;/a&gt; comes with a build cache backend. You don’t need to use the &lt;code class="highlighter-rouge"&gt;--parallel&lt;/code&gt; option as Gradle does incremental and parallel compilation and linking by default.&lt;/p&gt;

&lt;p&gt;Let’s run some clean builds that use the build cache:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/05-build-cache.gif" alt="./gradlew assemble with build cache" /&gt;&lt;/p&gt;

&lt;p&gt;You can see that the second build is faster, as the result is fetched from the build cache rather than recompiled. Build scans for &lt;a href="https://gradle.com/s/grhgj6t3t2bpq"&gt;non-cached build&lt;/a&gt; and &lt;a href="https://gradle.com/s/rgbum6d7eysu6"&gt;cached build&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/cached-vs-non-cached.png" alt="cached vs non-cached assemble" /&gt;&lt;/p&gt;

&lt;h2 id="publishing-c-libraries"&gt;Publishing C++ libraries&lt;/h2&gt;

&lt;p&gt;The new plugins can publish C++ libraries to a Maven or Ivy repository. Support for other kinds of repositories will be added later. Here is the &lt;a href="https://github.com/gradle/native-samples/tree/master/cpp/simple-library"&gt;build&lt;/a&gt; for the library we saw earlier.&lt;/p&gt;

&lt;p&gt;The build script adds a Maven repository to publish the binaries to:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;plugins&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="s1"&gt;'cpp-library'&lt;/span&gt;
    &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="s1"&gt;'maven-publish'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'org.gradle.cpp-samples'&lt;/span&gt;
&lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'1.5'&lt;/span&gt;

&lt;span class="n"&gt;publishing&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;repositories&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;maven&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// In this sample, we used a local maven repository, &lt;/span&gt;
            &lt;span class="c1"&gt;// but Maven Central or Artifactory server can be used.&lt;/span&gt;
            &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="s1"&gt;'http://localhost:8000/'&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is the result of running &lt;code class="highlighter-rouge"&gt;./gradlew publish&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/06-publishing.gif" alt="./gradlew publish" /&gt;&lt;/p&gt;

&lt;h2 id="composite-builds"&gt;Composite builds&lt;/h2&gt;

&lt;p&gt;Composite builds also work the same as in Java projects. This &lt;a href="https://github.com/gradle/native-samples/tree/master/cpp/composite-build"&gt;sample using a composite build&lt;/a&gt; combines builds so they can be worked on together:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;rootProject&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'app'&lt;/span&gt;

&lt;span class="n"&gt;includeBuild&lt;/span&gt; &lt;span class="s1"&gt;'list-library'&lt;/span&gt;
&lt;span class="n"&gt;includeBuild&lt;/span&gt; &lt;span class="s1"&gt;'utilities-library'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here’s the result in Xcode. The application and the libraries it uses are available to edit, build and test together:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/07-xcode-ide.png" alt="Xcode integration" /&gt;&lt;/p&gt;

&lt;p&gt;Finally, it’s easy to set up a CI build for our application. We’ve added &lt;a href="https://github.com/gradle/native-samples/blob/master/.travis.yml"&gt;configuration for Travis CI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://travis-ci.org/gradle/native-samples"&gt;&lt;img src="/images/introducing-the-new-cpp-plugins/native-samples-travis-ci.png" alt="Native Samples Travis CI" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="your-feedback-wanted"&gt;Your Feedback Wanted&lt;/h2&gt;

&lt;p&gt;These plugins are a work in progress and have some limitations. For example, binary publishing doesn’t understand operating system or architecture yet.  We’ll continue to improve these plugins, make them stable, and eventually will deprecate the software model plugins.&lt;/p&gt;

&lt;p&gt;Please try these plugins out and let us know what you think. The easiest way to get started is to clone the &lt;a href="https://github.com/gradle/native-samples"&gt;native samples&lt;/a&gt; repository and follow the instructions. Our samples use a &lt;a href="https://gradle.org/nightly/"&gt;Gradle nightly build&lt;/a&gt;, so you’ll see the latest and greatest developments there. Some changes are already showing up in the &lt;a href="https://docs.gradle.org/4.5-rc-1/release-notes.html#c/c++-compilation-improvements"&gt;4.5 release candidates&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’d love to hear what you think works well, what’s confusing, and what is missing that would block you from using Gradle to build C++ software. You can also leave feedback on the &lt;a href="https://discuss.gradle.org/"&gt;Gradle forums&lt;/a&gt; or raise issues on the &lt;a href="https://github.com/gradle/gradle-native"&gt;Gradle native&lt;/a&gt; GitHub repository.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Multi-release JARs - Good or bad idea?</title>
    <link href="https://blog.gradle.org/mrjars"/>
    <updated>2017-12-19T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/mrjars</id>
    <author>
      <name>Cédric Champeau</name>
    </author>
    <content type="html">
      &lt;p&gt;With Java 9 came a new feature of the Java runtime called multi-release jars. For us at Gradle, it’s probably one of the most controversial additions to the platform. TL/DR, we think it’s a wrong answer to a real problem. This post will explain why we think so, but also explain how you can build such jars if you really want to.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://openjdk.java.net/jeps/238"&gt;Multi-release JARs&lt;/a&gt;, aka MRJARs, are a new feature of the Java platform, included in the Java 9 JDK. In this post, we will elaborate on the significant risks of adopting this technology and provide how one can produce and consume multi-release JARs with Gradle, if desired.&lt;/p&gt;

&lt;p&gt;In a nutshell, multi-release jars allow you to package several versions of the same class, for consumption by different runtimes. For example, if you run on JDK 8, the Java runtime would use the Java 8 version of the class, but if you run on Java 9, it would use the Java 9 specific implementation. Similarly, if a version is built for the upcoming Java 10 release, then the runtime would use it instead of the Java 9 and default (Java 8) versions.&lt;/p&gt;

&lt;h2 id="use-cases-for-multi-release-jars"&gt;Use Cases for multi-release JARs&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Optimized runtime. This answers a problem that lots of developers have faced in real world: when you develop an application, you don’t know in what runtime it’s going to be executed. However, you know that for some runtimes you can implement optimized versions of the same class. For example, imagine that you want to display the Java version number that your application is currently executed on. For Java 9, you can use the &lt;code class="highlighter-rouge"&gt;Runtime.getVersion&lt;/code&gt; method. However, this is a new method only available if you run on Java 9+. If you target more runtimes, say, Java 8, then you need to parse the &lt;code class="highlighter-rouge"&gt;java.version&lt;/code&gt; property. So you end up with 2 different implementations of the same feature.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Conflicting APIs : Another common use case is to handle conflicting APIs. For example, you need to support 2 different runtimes, but one has deprecated APIs. There are currently 2 widely used solutions to this problem:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;The first one is to use reflection. One could for example define a &lt;code class="highlighter-rouge"&gt;VersionProvider&lt;/code&gt; interface, then 2 concrete classes &lt;code class="highlighter-rouge"&gt;Java8VersionProvider&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Java9VersionProvider&lt;/code&gt;, the right one being loaded at runtime (note that funnily to be able to choose between the 2 you might have to parse the version number!). A variant of this solution is just to have a single class, but different methods, accessing and calling different methods by reflection.&lt;/li&gt;
      &lt;li&gt;A more advanced solution would be to use method handles for this, if it is technically applicable. Most likely, you would see reflection as both painful to implement and slow, and you would most likely be right.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="well-known-alternatives-to-multi-release-jars"&gt;Well known alternatives to multi-release JARs&lt;/h2&gt;

&lt;p&gt;The second solution, easier to maintain and reason about, is to provide 2 different jars, aimed at 2 different runtimes. Basically, you would write the 2 implementations for the same class in your IDE, and it’s the build tool responsibility to compile, test and package them correctly into 2 different artifacts. This is the approach that some tools like Guava or Spock for example have been using for years. But it’s also what some languages like Scala need. Because there are so many variants of the compiler and the runtime, that binary compatibility is almost impossible to maintain.&lt;/p&gt;

&lt;p&gt;But there are more reasons to prefer separate jars:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a jar is &lt;em&gt;just&lt;/em&gt; packaging
    &lt;ul&gt;
      &lt;li&gt;it’s an artifact of the build that happens to package classes, but not only: resources would typically be bundled into a jar too. Packaging, as well as processing resources, has a cost. What we’re trying to do with Gradle is to improve the performance of builds, and reduce the amount of time a developer has to wait to see results of compilation, tests, and in general the whole build process. By forcing to build a jar too early in the process, you create a redundant point of synchronization. For example, to compile downstream consumers, the only thing the consumer needs is the .class files. It doesn’t need the jar, nor does it need the resources in the jar. Similarly, to execute tests, all Gradle needs is the class files, plus the resources. There’s no need to actually &lt;em&gt;create&lt;/em&gt; the jar to execute tests. The jar is only needed once an external consumer will require it (in short, publishing). But as soon as you consider the artifact as a requirement, then you’re blocking some tasks from running concurrently, and you’re slowing down the whole build. While for small projects this might not be an issue, for enterprise scale builds, this is a major blocker.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;more importantly, as an artifact, a jar shouldn’t carry information about dependencies.
    &lt;ul&gt;
      &lt;li&gt;There’s absolutely no reason why the runtime dependencies of your Java 9 specific class would be the same as the Java 8 one. In our very simplistic example they would, but for larger project this is wrong modeling: typically, users would import a backport library of a Java 9 feature, and use it to implement the Java 8 version of the class. However, if you package both versions in the same jar, then you’re mixing things that don’t have the same dependency trees into a single artifact. It means, typically, that if you happen to run on Java 9, you’re bringing a dependency that you would never ever use. Worse, it can (and will) pollute your classpath, possibly creating conflicts for consumers.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Eventually, for a single project, you can produce different jars, aimed at different usages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;one for the API&lt;/li&gt;
  &lt;li&gt;one for Java 8 runtime&lt;/li&gt;
  &lt;li&gt;one for Java 9&lt;/li&gt;
  &lt;li&gt;one with native bindings&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Abuse of the &lt;code class="highlighter-rouge"&gt;classifier&lt;/code&gt; leads to inconsistent things being referred to using the same mechanism. Typically, the &lt;code class="highlighter-rouge"&gt;sources&lt;/code&gt; or &lt;code class="highlighter-rouge"&gt;javadocs&lt;/code&gt; jars are posted as classifiers, but don’t really have any dependency.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we don’t want to create a mismatch depending on &lt;em&gt;how&lt;/em&gt; you get your classes. In other words, using multi-release jars have the side effect that consuming from a jar and consuming from a class directory are no longer equivalent. There’s a semantic difference between the 2, which is terrible!&lt;/li&gt;
  &lt;li&gt;depending on the tool that is going to create the jar, you may produce inconsistent jars! The only tool so far that guarantees that if you package the same class twice in a jar, both of them have the same public API, is the &lt;code class="highlighter-rouge"&gt;jar&lt;/code&gt; tool itself. Which, for lots of good reasons is not necessarily used by build tools, or even users. A jar, in practice, is just an envelope. It’s a zip in disguise. So depending on how you build it, you would have different behavior, or you could just produce wrong artifacts and never notice.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="better-ways-to-manage-separate-jars"&gt;Better ways to manage separate JARs&lt;/h2&gt;

&lt;p&gt;The main reason developers don’t use separate jars is that they are impractical to produce and consume. The fault is on build tools, which, until Gradle, have dramatically failed at handling this. In particular, developers who have used this solution had no other choice than relying on the very poor &lt;code class="highlighter-rouge"&gt;classifier&lt;/code&gt; feature of Maven to publish additional artifacts. However, classifiers are very bad at modelling the complexity of the situation. They are used for a variety of different aspects, from publishing sources, documentation, javadocs, to publishing &lt;em&gt;variants&lt;/em&gt; of a library (&lt;code class="highlighter-rouge"&gt;guava-jdk5&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;guava-jdk7&lt;/code&gt;, …) or different usages (api, fat jar, …). And in practice, there’s no way to indicate that the dependency tree of a &lt;code class="highlighter-rouge"&gt;classifier&lt;/code&gt; is not the one of the project itself. In other words, the POM is broken, as it represents both how the component is built, and what artifacts it produces. Say that you want to produce 2 different jars: one classic jar, and one &lt;code class="highlighter-rouge"&gt;fat jar&lt;/code&gt; that bundles all dependencies. In practice Maven would consider that the 2 artifacts have equal dependency trees, even if it’s plain wrong! It’s super obvious in this case, but the situation is exactly the same with multi-release jars!&lt;/p&gt;

&lt;p&gt;The solution is to handle variants properly. That’s what we call variant-aware dependency management, and Gradle knows how to do it. So far this feature has only been enabled for Android development, but we’re currently developing it for Java and native too!&lt;/p&gt;

&lt;p&gt;Variant-aware dependency management is the idea that modules and artifacts are different beasts. With the same source files, you can target different runtimes, with different requirements. For the native world it has been obvious for years: we compile for i386 and amd64, and there’s no way you can mix the dependencies of a i386 library with the ones of arm64! Transposed to the Java world, it means that if you target Java 8, you should produce a java 8 version of your jar, with classes targeting the Java 8 class format. This artifact would have metadata attached so that Java 8 consumers know what dependencies to use. And if you target Java 9, then the Java 9 dependencies would be selected. It’s as simple as that (well, in practice it’s not because the runtime is only one dimension of the variants, and you can combine multiple).&lt;/p&gt;

&lt;p&gt;Of course, nobody has ever done this before because it’s complex to handle: Maven would for sure never let you do such complex thing. But Gradle makes it possible. And the good news is that we’re also developing a new metadata format that will let consumers know which variant they should use. Simply said, the build tool needs to deal with the complexity of compiling, testing, packaging, but also consuming such modules. For example, say that you want to support Java 8 and Java 9 as runtimes. Then, &lt;em&gt;ideally&lt;/em&gt;, you need to compile 2 versions of your library. Which means 2 different compilers (to avoid using the Java 9 APIs while targeting Java 8), 2 different class directories, and 2 different jars in the end. But also, you will probably want to test the 2 different runtimes. Or, you might want to build the 2 jars, but still want to test what the behavior of the Java 8 version is when executed on a Java 9 runtime (because, it may happen in production!).&lt;/p&gt;

&lt;p&gt;We’ve made &lt;a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md"&gt;significant progress&lt;/a&gt; towards modelling this, and even if we’re not ready yet, it explains why we are not so keen on using multi-release jars: while they fix a problem, they are fixing it the wrong way, and Maven Central is going to be bloated with libraries that do not declare their dependencies properly!&lt;/p&gt;

&lt;h2 id="how-to-create-a-multi-release-jar-with-gradle"&gt;How to create a multi-release JAR with Gradle&lt;/h2&gt;

&lt;p&gt;It’s not ready so what should I do? The good news is that the path to generate correct artifacts is the same. Until this new feature is ready for the Java ecosystem, you have 2 different options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;do it the old way, using reflection or distinct jars.&lt;/li&gt;
  &lt;li&gt;use multi-release jars, (being aware that you may take the wrong decision here, even if there are good use cases)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Whatever solution you choose, separate jars route or the multi-release jars, both use the same setup. Multi-release jars are only the wrong (default) packaging: they should be an &lt;em&gt;option&lt;/em&gt;, not a goal. Technically, the source layout is the same for both separate jars and external jars. This &lt;a href="https://github.com/melix/mrjar-gradle"&gt;repository&lt;/a&gt; explains how you can create a multi-release jar with Gradle, but here is how it works in a nutshell.&lt;/p&gt;

&lt;p&gt;First, you must understand that we as developers often have a very bad habit: we tend to run Gradle (or Maven) using the same Java version that the artifacts you want to produce. Sometimes it’s even worse, when we use a more recent version to run Gradle, and compile using an older API level. But there’s no good reason to do this. Gradle supports &lt;a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_cross_compilation"&gt;cross-compilation&lt;/a&gt;. It allows you to explain where a JDK is found, and fork compilation to use this specific JDK to compile a component. A reasonable way to setup different JDKs is to configure the path to the JDKs through environment variables, which is what we are doing &lt;a href="https://github.com/melix/mrjar-gradle/blob/master/jdks.gradle"&gt;in this file&lt;/a&gt;. Then we only need to configure Gradle to use the appropriate JDK &lt;a href="https://github.com/melix/mrjar-gradle/blob/master/jdks.gradle#L12-L23"&gt;based on the source/target compatibility&lt;/a&gt;. It’s worth noting that starting from JDK 9, it’s no longer necessary to provide older JDKs to perform cross-compilation. A new option, &lt;code class="highlighter-rouge"&gt;-release&lt;/code&gt;, does exactly that. Gradle will &lt;a href="https://github.com/melix/mrjar-gradle/blob/master/jdks.gradle#L35"&gt;recognize this option and configure the compiler accordingly&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The second key concept is the notion of &lt;a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_source_sets"&gt;source set&lt;/a&gt;. A source set represents a set of sources that are going to be compiled together. A jar is built from the result of the compilation of one or more source sets. For each source set, Gradle will automatically create a corresponding compile task that you can configure. This means that if we have sources for Java 8 and sources for Java 9, then they should live in separate source sets. That’s what we do by creating a &lt;a href="https://github.com/melix/mrjar-gradle/blob/master/build.gradle#L4-L10"&gt;Java 9 specific source set&lt;/a&gt; that will contain the specialized version of our class. This matches reality, and doesn’t force you to create a separate project like Maven would require. But more importantly, it allows us to precisely configure &lt;em&gt;how&lt;/em&gt; this source set is going to compile.&lt;/p&gt;

&lt;p&gt;Part of the challenge of multiple versions of a single class is that it’s very rare that such a class is totally independent from the rest of the code (it has dependencies onto classes that are found in the main source set). For example, its API would use classes that don’t need to have Java 9 specific sources. Yet, you don’t want to recompile all those common classes, nor do you want to package Java 9 versions of all those classes. They are really shared and should stay separate. This is what &lt;a href="https://github.com/melix/mrjar-gradle/blob/master/build.gradle#L19"&gt;this line&lt;/a&gt; is about: it will configure the dependency between the Java 9 source set and the main source set, making sure that when we compile the Java 9 specific version, all common classes are on compile classpath.&lt;/p&gt;

&lt;p&gt;The &lt;a href="https://github.com/melix/mrjar-gradle/blob/master/build.gradle#L22-L30"&gt;next step&lt;/a&gt; is really simple: we need to explain to Gradle that the main source set is going to target Java 8 language level, and that the Java 9 source set is going to target Java 9 language level.&lt;/p&gt;

&lt;p&gt;All the steps we have described so far allow you both approaches described previously: publishing separate jars, or publishing a multi-release jar. Since this is the topic of this blog post, let’s see how we can now tell Gradle that we will only generate a multi-release jar:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;
&lt;span class="n"&gt;jar&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;into&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'META-INF/versions/9'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;sourceSets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;java9&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;output&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;manifest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;attributes&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;
     &lt;span class="s1"&gt;'Multi-Release'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'true'&lt;/span&gt;
  &lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This configuration block does 2 separate things: bundle the Java 9 specific classes into the &lt;code class="highlighter-rouge"&gt;META-INF/versions/9 directory&lt;/code&gt;, which is expected in a MRJar add the multi-release flag to the manifest.&lt;/p&gt;

&lt;p&gt;And that’s it, you’ve built your first MRJar! However we’re not done yet, unfortunately. If you are familiar with Gradle, you would know that if you apply the &lt;code class="highlighter-rouge"&gt;application&lt;/code&gt; plugin you can also run the application directly with a &lt;code class="highlighter-rouge"&gt;run&lt;/code&gt; task. However, because as usual Gradle tries to perform the minimal amount of work to do what you need, the &lt;code class="highlighter-rouge"&gt;run&lt;/code&gt; task is wired to use the class directories as well as the processed resources directories. And for multi-release jars, that’s a problem, because you need the jar now! So instead of relying on this plugin we have no choice but &lt;a href="https://github.com/melix/mrjar-gradle/blob/master/build.gradle#L46-L50"&gt;creating our own task&lt;/a&gt;, which is another reason why not use multi-release jars.&lt;/p&gt;

&lt;p&gt;Last but not least, we said we probably also want to test the 2 versions of our class. For this, you have no choice but using forked VMs, because there’s no equivalent to the &lt;code class="highlighter-rouge"&gt;-release&lt;/code&gt; flag for the Java runtime. The idea, here, is that you write a single unit test, but it’s going to be executed twice: once with Java 8, the other with Java 9 runtime. This is the only way to make sure that your substituted classes work properly. By default, Gradle only creates a single test task, and it will also use the class directories instead of the jar. So we need to do two things:
create a Java 9 specific test task
configure both test tasks so that they use the jar and specific Java runtimes&lt;/p&gt;

&lt;p&gt;This can be achieved simply by doing this:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;
&lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;dependsOn&lt;/span&gt; &lt;span class="n"&gt;jar&lt;/span&gt;
   &lt;span class="kt"&gt;def&lt;/span&gt; &lt;span class="n"&gt;jdkHome&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getenv&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"JAVA_8"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;classpath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;archivePath&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;classpath&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;sourceSets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;main&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;output&lt;/span&gt;
   &lt;span class="n"&gt;executable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"$jdkHome/bin/java"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;doFirst&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;println&lt;/span&gt; &lt;span class="s2"&gt;"$name runs test using JDK 8"&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="nf"&gt;testJava9&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;type:&lt;/span&gt; &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;dependsOn&lt;/span&gt; &lt;span class="n"&gt;jar&lt;/span&gt;
   &lt;span class="kt"&gt;def&lt;/span&gt; &lt;span class="n"&gt;jdkHome&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getenv&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"JAVA_9"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;classpath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;archivePath&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;classpath&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;sourceSets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;main&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;output&lt;/span&gt;
   &lt;span class="n"&gt;executable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"$jdkHome/bin/java"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;doFirst&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;println&lt;/span&gt; &lt;span class="n"&gt;classpath&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;asPath&lt;/span&gt;
       &lt;span class="n"&gt;println&lt;/span&gt; &lt;span class="s2"&gt;"$name runs test using JDK 9"&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;dependsOn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testJava9&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now if you run the &lt;code class="highlighter-rouge"&gt;check&lt;/code&gt; task, Gradle will compile each source set using the proper JDK, build a multi-release jar, then run unit tests using this jar on both JDKs. Future versions of Gradle will help you do this in a more declarative way.&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In conclusion, we’ve seen that multi-release jars address a real problem that a significant number of library designers face. However, we think this is the wrong solution to the problem. Correct modeling of dependencies, as well as coupling of artifacts and variants, and not forgetting performance (ability to execute more tasks concurrently) make them a poor man’s solution to a problem we are fixing the right way, using variant-aware dependency management. However, we reckon that for simple use cases, knowing that variant-aware dependency management for Java is not yet completed, it may be convenient to produce such a jar. In that case, and only in that case, this post helped you understand how you can do this, and how the philosophy of Gradle differs from Maven in this case (source set vs project).&lt;/p&gt;

&lt;p&gt;Finally, we don’t deny that there are cases where multi-release jars do make sense: applications for which the runtime is not known in advance, for example, but those are exceptional and should be considered as such. Most issues are for &lt;em&gt;library designers&lt;/em&gt;: we’ve covered common problems they face, and how multi-release JARs attempt to solve some of them. Modeling dependencies correctly as variants improves performance (via finer-grained parallelism) and reduces maintenance overhead (avoiding accidental complexity) over the use of multi-release JARs. Your situation may dictate that MRJARs be used; rest assured that it’s still supported by Gradle. See &lt;a href="https://github.com/melix/mrjar-gradle"&gt;this mrjar-gradle example project&lt;/a&gt; to try this today.&lt;/p&gt;


    </content>
  </entry>
  <entry>
    <title>State of Gradle Java 9 Support</title>
    <link href="https://blog.gradle.org/java-9-support-update"/>
    <updated>2017-10-17T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/java-9-support-update</id>
    <author>
      <name>Eric Wendelin</name>
    </author>
    <content type="html">
      &lt;p&gt;This post provides an overview of Gradle’s Java 9 support, touching on runtime, cross-compilation, MRJARs, and Jigsaw modules support. We’ve fielded lots of questions since Java 9 was released last month, and decided it best to answer here.&lt;/p&gt;

&lt;h2 id="what-gradle-supports-as-of-version-421"&gt;What Gradle supports as of version 4.2.1&lt;/h2&gt;

&lt;p&gt;As of Gradle 4.2.1, building and running Java applications using major distributions of JDK 9 such as Oracle JDK9, OpenJDK9 and Azul JDK9 is fully supported. Further, cross-compilation (built by JDK9 but runs on JDK8) is supported.&lt;/p&gt;

&lt;p&gt;Some builds will break when upgrading to Java 9, regardless of build tool used. The Java team have made good and necessary changes to the JDK to facilitate better software architecture and security, but this has meant removing access to some APIs. Even if your project is ready, some tools and Gradle plugins have not yet been updated to work with Java 9.&lt;/p&gt;

&lt;p&gt;There is no convenience methods for consuming and assembling Multi-Release JARs, but you can take a look at this &lt;a href="https://github.com/melix/mrjar-gradle"&gt;MRJAR-gradle example&lt;/a&gt; if you desire to use them.&lt;/p&gt;

&lt;h2 id="java-modules-aka-jigsaw-support"&gt;Java Modules aka Jigsaw Support&lt;/h2&gt;

&lt;p&gt;If you’re not yet familiar with the Java 9 Platform Module System, also known as Project Jigsaw, you should read &lt;a href="http://openjdk.java.net/projects/jigsaw/quick-start"&gt;Project Jigsaw: Module System Quick-Start Guide&lt;/a&gt;. The motivation and terminology are well explained in &lt;a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/"&gt;The State of the Module System&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A module is defined as “a named, self-describing collection of code and data” whereby packages are treated as code boundaries, and are explicitly &lt;em&gt;exported&lt;/em&gt; and &lt;em&gt;required&lt;/em&gt;. Non-exported packages are not visible to module consumers, and further 2 modules cannot export the same packages, nor can they have the same internal packages. This means that packages cannot be “split” or duplicated between multiple modules, or compilation will fail.&lt;/p&gt;

&lt;p&gt;Here is a &lt;a href="https://guides.gradle.org/building-java-9-modules/"&gt;guide that shows how to use Java modules&lt;/a&gt; with Gradle today. It walks you through the steps necessary to tell Gradle to use the &lt;code class="highlighter-rouge"&gt;modulepath&lt;/code&gt; and not &lt;code class="highlighter-rouge"&gt;classpath&lt;/code&gt; when compiling Java sources and patch modules for testing purposes.&lt;/p&gt;

&lt;p&gt;A bottom-up approach (convert libraries with no dependencies first) is recommended if you wish to incrementally convert to Java 9 modules. After all, modules are consumable as regular JARs. Be mindful of &lt;a href="http://blog.joda.org/2017/05/java-se-9-jpms-automatic-modules.html"&gt;automatic modules&lt;/a&gt; when “legacy” JARs are added to the &lt;code class="highlighter-rouge"&gt;modulepath&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="achieving-encapsulation-with-the-java-library-plugin"&gt;Achieving encapsulation with the Java Library Plugin&lt;/h2&gt;

&lt;p&gt;One of the 2 major goals of the Java 9 module system is to provide better software architecture through strong encapsulation. Gradle 3.4 introduced the &lt;a href="https://docs.gradle.org/current/userguide/java_library_plugin.html"&gt;Java Library Plugin&lt;/a&gt; that enforces strong encapsulation for libraries by separating &lt;code class="highlighter-rouge"&gt;api&lt;/code&gt; dependencies (those meant to be exposed to consumers) from &lt;code class="highlighter-rouge"&gt;implementation&lt;/code&gt; dependencies whose internals are not leaked to consumers.&lt;/p&gt;

&lt;p&gt;This, of course, does not eliminate use of Java classpaths as is &lt;a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/"&gt;stated as another goal of Java modules&lt;/a&gt;. You can learn about the motivation and usage of the Java Library Plugin in &lt;a href="https://blog.gradle.org/incremental-compiler-avoidance"&gt;this post&lt;/a&gt;. It’s worth noting that the Java Library Plugin is useful for projects using Java 7 and above — you do not need to migrate to Java 9 to have some stronger encapsulation.&lt;/p&gt;

&lt;p&gt;Here’s what this means in practice, given this example library:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;apply&lt;/span&gt; &lt;span class="nl"&gt;plugin:&lt;/span&gt; &lt;span class="s1"&gt;'java-library'&lt;/span&gt;

&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'mylibrary'&lt;/span&gt;
&lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'com.mycompany'&lt;/span&gt;

&lt;span class="n"&gt;dependencies&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;api&lt;/span&gt; &lt;span class="nf"&gt;project&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;':model'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;implementation&lt;/span&gt; &lt;span class="s1"&gt;'com.google.guava:guava:18.0'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s presume we have an application that uses &lt;code class="highlighter-rouge"&gt;mylibrary&lt;/code&gt;.&lt;/p&gt;

&lt;div class="language-java highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyApplication&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// This does not compile using 'java-library' plugin&lt;/span&gt;
        &lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;strings&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;google&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;common&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;collect&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ImmutableSet&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;of&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Goodbye"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        
        &lt;span class="c1"&gt;// This compiles and runs&lt;/span&gt;
        &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;mycompany&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;internal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        
        &lt;span class="c1"&gt;// This also compiles and runs&lt;/span&gt;
        &lt;span class="n"&gt;Class&lt;/span&gt; &lt;span class="n"&gt;clazz&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MyApplication&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getClassLoader&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;loadClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"com.mycompany.model.internal.Foo"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;clazz&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getConstructor&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;newInstance&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can see that you get some of the benefits by adopting the Gradle’s Java Library plugin. If you are migrate to Java modules, you can use this rough mapping:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;implementation&lt;/code&gt; dependency =&amp;gt; &lt;code class="highlighter-rouge"&gt;requires&lt;/code&gt; module declaration&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;api&lt;/code&gt; dependency =&amp;gt; &lt;code class="highlighter-rouge"&gt;requires transitive&lt;/code&gt; module declaration&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;runtimeOnly&lt;/code&gt; dependency =&amp;gt; &lt;code class="highlighter-rouge"&gt;requires static&lt;/code&gt; module declaration&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="next-steps"&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://blog.gradle.org/subscribe"&gt;Stay tuned&lt;/a&gt; for updates on first-class Java modules support in Gradle.&lt;/p&gt;

&lt;p&gt;You can use the &lt;a href="https://guides.gradle.org/building-java-9-modules/"&gt;Building Java 9 Modules guide&lt;/a&gt; to learn how to use Java modules with Gradle today.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Join Gradle at KotlinConf 2017</title>
    <link href="https://blog.gradle.org/kotlinconf-2017"/>
    <updated>2017-10-10T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/kotlinconf-2017</id>
    <author>
      <name>Eric Wendelin</name>
    </author>
    <content type="html">
      &lt;p&gt;Kotlin is the #1 rising Gradle “related topic” &lt;a href="https://trends.google.com/trends/explore?geo=US&amp;amp;q=%2Fm%2F080c0g9"&gt;according to Google Trends&lt;/a&gt;. We want to improve user experience developing Kotlin applications with Gradle, and that requires great guides — but we need your help! Tell us which unwritten Kotlin Gradle guide you think would be most useful, and you’ll have &lt;em&gt;a chance to get a free ticket&lt;/em&gt; to &lt;a href="https://kotlinconf.com/"&gt;KotlinConf&lt;/a&gt;! See instructions below.&lt;/p&gt;

&lt;p style="text-align: center"&gt;
&lt;img src="/images/kotlinconf-wide.png" alt="KotlinConf 2-3 Nov 2017, San Francisco, Pier 27" /&gt;
&lt;/p&gt;

&lt;p&gt;We are proud to be a silver partner for &lt;a href="https://kotlinconf.com/"&gt;KotlinConf&lt;/a&gt;, which is just 3 weeks away! Hans Dockter will be presenting &lt;a href="https://www.kotlinconf.com/speakers/#speaker=hans-dockter"&gt;Building Kotlin Applications at Scale&lt;/a&gt; and some of the &lt;a href="https://github.com/gradle/kotlin-dsl"&gt;Gradle Kotlin DSL&lt;/a&gt; team will be on-site to talk Kotlin with you.&lt;/p&gt;

&lt;h3 id="about-the-kotlinconf-2017-ticket-raffle"&gt;About the KotlinConf 2017 ticket raffle&lt;/h3&gt;

&lt;p&gt;We are giving away 2 standard tickets to the conference. You’ll be responsible for getting to the conference, so please don’t accept a ticket if you cannot attend.&lt;/p&gt;

&lt;p&gt;All you need to do is file an issue on the &lt;a href="https://github.com/gradle/guides/"&gt;gradle/guides GitHub repo&lt;/a&gt; with a unique and useful suggestion for a Gradle guide around building Kotlin with Gradle. For inspiration, you can check out the &lt;a href="https://github.com/gradle/guides/issues/95"&gt;proposal for the Building Kotlin JVM Libraries guide&lt;/a&gt;, which was published recently.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;We’d be happy to get lots of good ideas from you, but we’ll enter your name once. Winners will be chosen at random on &lt;em&gt;Monday, October 16th&lt;/em&gt;. We’ll contact you if you’ve been selected, and you’ll have 3 days to confirm you can attend.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;: Thank you everyone! The contest is now closed.&lt;/p&gt;

&lt;p&gt;If you’re interested in contributing to the Kotlin/Gradle community, just adding 👍 s on ideas you think would be good is helpful, but even more so submitting a PR with a sample or typo fix is most welcome. Remember the goal: make Kotlin development awesome for everyone!&lt;/p&gt;

&lt;p&gt;Good luck! We hope to see you at &lt;a href="https://kotlinconf.com/"&gt;KotlinConf&lt;/a&gt;!&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>State and future of the Gradle Software Model</title>
    <link href="https://blog.gradle.org/state-and-future-of-the-gradle-software-model"/>
    <updated>2017-08-24T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/state-and-future-of-the-gradle-software-model</id>
    <author>
      <name>Daniel Lacasse</name>
    </author>
    <content type="html">
      &lt;p&gt;We’ve received many inquiries about the status and direction of &lt;a href="https://docs.gradle.org/current/userguide/pt06.html"&gt;Gradle’s Software Model&lt;/a&gt;, especially from users building native libraries and applications.&lt;/p&gt;

&lt;p&gt;In this blog post, we will explain the current state and future of the Software Model, and in particular how it relates to native development with Gradle. A lot of exciting improvements are planned for the remainder of 2017; see the &lt;a href="#a-way-forward"&gt;roadmap below&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="situation-with-the-software-model"&gt;Situation with the Software Model&lt;/h2&gt;

&lt;p&gt;In a nutshell, the Software Model is a very declarative way to describe how a piece of software is built and the other components it needs as dependencies in the process. It also provides a new, rule-based engine for configuring a Gradle build. When we started to implement the Software Model we set ourselves the following goals:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Improve configuration and execution time performance.&lt;/li&gt;
  &lt;li&gt;Make customizations of builds with complex tool chains easier.&lt;/li&gt;
  &lt;li&gt;Provide a richer, more standardized way to model different software ecosystems&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As we were developing the Software Model, the Gradle engineering team constantly tried to dogfood the concepts into existing software ecosystems. The Gradle plugins for building native applications is currently fully-based on the Software Model. Similarly, experimental Software Model-based plugins were developed for ecosystems like Android and Java.&lt;/p&gt;

&lt;p&gt;Gradle adoption in the native ecosystem is picking up, and so is our investment. Since it’s inception, &lt;a href="https://docs.gradle.org/current/userguide/native_software.html"&gt;Gradle’s native support&lt;/a&gt; has proved itself as a welcome alternative for builds using Make. With its declarative and expressive model, support for different tool chains and platforms as well as features like parallel compilations, it offers a revolutionary way for building native libraries and applications.&lt;/p&gt;

&lt;p&gt;It took us longer than expected to evolve the new configuration and Software Model and make it as powerful as the current Gradle model for Java and Android. Meanwhile, Gradle adoption skyrocketed, there are many complex builds out there using the current model and a vibrant ecosystem of 1500+ community plugins as well. We underestimated the complexity for those builds and plugins to migrate to the new model and saw understandable resistance with many of our partners to undergo this migration.&lt;/p&gt;

&lt;p&gt;In hindsight, the scope of the new software and configuration model was too big. That is why at the Gradle Summit 2016, Hans Dockter &lt;a href="https://www.youtube.com/watch?v=lFugHBBsGe4&amp;amp;feature=youtu.be&amp;amp;t=2098"&gt;announced&lt;/a&gt; that we were backporting many of its features to the current model. One year later, most of the features for the Java and Android ecosystem have been backported. This includes variant-aware dependency resolution and &lt;a href="https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_separation"&gt;separation of API and implementation&lt;/a&gt; for Java components. Those features were game changers in terms of &lt;a href="https://blog.gradle.org/incremental-compiler-avoidance"&gt;work avoidance&lt;/a&gt; and &lt;a href="https://blog.gradle.org/blazing-fast-android-builds"&gt;performance&lt;/a&gt;. Furthermore, we found other ways to drastically improve Gradle configuration performance, with more to come. There is no longer any need for a drastic, incompatible change in how Gradle builds are configured.&lt;/p&gt;

&lt;h2 id="a-way-forward"&gt;A way forward&lt;/h2&gt;

&lt;p&gt;You may therefore be wondering what is happening to the Software Model. We’re in the process of porting the configuration DSL of the native support to the current model. So the declarative nature and strong modelling language will be the same. &lt;em&gt;The rule engine that was part of the Software Model will be deprecated.&lt;/em&gt; Everything under the model block will be ported as extensions to the current model. Native users will no longer have a separate extension model compared to the rest of the Gradle community, and they will be able to make use of the new variant aware dependency management.&lt;/p&gt;

&lt;p&gt;What does the roadmap look like? Here are the areas of focus until the end of the year:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Current model support for native&lt;/strong&gt;. New sets of plugins based on the current model are in development and are improved with every nightly release. They still need more work to achieve feature parity and stability, but already provide a lot of functionality. &lt;a href="https://github.com/gradle/native-samples"&gt;Try them out&lt;/a&gt; and give us feedback.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Parallel-by-default for compile and link tasks&lt;/strong&gt;. Performance improvements are planned for the native ecosystem by enabling parallelism-by-default to compile and link tasks. This will have a positive impact on everyone building native with Gradle.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Transitive dependency resolution&lt;/strong&gt;. We are porting this powerful feature from our JVM ecosystem to help native developers declare rich dependencies between native projects.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;New native plugins on current model&lt;/strong&gt;. Our plan is to have plugins that have most of the functionality of the Software Model plugins and will also have substantial new features like build caching and external source dependencies for native.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Improved tool chain support&lt;/strong&gt;. We are looking at ironing out some of the wrinkles with tool chain declaration which is particularly important for embedded development.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the most complete and up-to-date progress, we recommend having a look at the &lt;a href="https://github.com/gradle/gradle-native"&gt;gradle-native project&lt;/a&gt;, the home for the native ecosystem feature planning.&lt;/p&gt;

&lt;p&gt;User migration from Software Model plugins to the new ones will be pretty seamless. All core native tasks will be reused and the tool chain concept will be ported to the current model. We expect that a lot of your build logic can be simply reused. We will support the Software Model-based plugins for an extended period of time to ensure everyone has a successful migration.&lt;/p&gt;

&lt;p&gt;If you are currently using, or are planning to use, Gradle to build native projects, by all means keep doing so. Gradle’s native support has proven time and time again to be more performant, flexible, and easier to use than currently available tools.&lt;/p&gt;

&lt;h3 id="exciting-things-afoot"&gt;Exciting things afoot&lt;/h3&gt;

&lt;p&gt;Today, we’re working on IDE integration and XCTest support, with out-of-the-box HTML report generation and &lt;a href="https://scans.gradle.com/"&gt;full build scan support&lt;/a&gt;. 
Tool chain definition will also be improved to allow easier integration with alternative tool chain families; this is especially exciting for users invested in the embedded world.&lt;/p&gt;

&lt;p&gt;For multi-repository developers, you will be happy to learn that &lt;a href="https://docs.gradle.org/current/userguide/composite_builds.html"&gt;composite builds&lt;/a&gt; will work for all native projects.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://scans.gradle.com/s/2o3l5zm63frhk"&gt;&lt;img src="/images/cpp-build-scan.png" alt="C++ Build Scan" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The new plugins will integrate with the &lt;a href="https://github.com/gradle/kotlin-dsl"&gt;Kotlin DSL&lt;/a&gt; which gives Gradle users proper IDE support including auto-completion and refactoring.&lt;/p&gt;

&lt;p&gt;We will first implement the complete workflow for native development in the current model without any customization - i.e. no platforms, build types or tool chains configuration. By workflow we mean everything related to building binaries, as well as testing, packaging, deploying and integration with your favorite IDE. At first, the workflow will work for the most common cases. In the subsequent releases, we will proceed by adding customization incrementally to the whole workflow.&lt;/p&gt;

&lt;h2 id="community-involvement"&gt;Community involvement&lt;/h2&gt;

&lt;p&gt;Our native community is one of the most active and engaged on &lt;a href="https://discuss.gradle.org/c/help-discuss"&gt;the forum&lt;/a&gt;, and we want to encourage and grow that engagement even more.
Please keep helping each other find the answers you are seeking in the forum, but also engage with us by, trying the &lt;a href="https://github.com/gradle/native-samples"&gt;various native sample projects&lt;/a&gt;, subscribing to the &lt;a href="https://github.com/gradle/gradle-native/issues"&gt;gradle-native project&lt;/a&gt; and filing issues, voting on issues that are most important to you, and even consider submitting pull requests if you’re excited to roll up your sleeves and pitch in.&lt;/p&gt;

&lt;p&gt;The best ways to stay passively up-to-date on native platform support are to subscribe to the &lt;a href="https://newsletter.gradle.com/"&gt;monthly newsletter&lt;/a&gt; or more frequent announcements &lt;a href="https://twitter.com/gradle"&gt;on Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We look forward to working with you to develop the best native build tool!&lt;/p&gt;


    </content>
  </entry>
  <entry>
    <title>Blazing Fast Android Builds</title>
    <link href="https://blog.gradle.org/blazing-fast-android-builds"/>
    <updated>2017-05-17T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/blazing-fast-android-builds</id>
    <author>
      <name>Stefan Oehme</name>
    </author>
    <content type="html">
      &lt;p&gt;At Google I/O today, the Android Studio team released the first preview version of the &lt;a href="https://android-developers.googleblog.com/2017/05/android-studio-3-0-canary1.html"&gt;Android Gradle plugin 3.0&lt;/a&gt;, based on &lt;a href="https://docs.gradle.org/4.0-milestone-2/release-notes.html"&gt;Gradle 4.0 M2&lt;/a&gt;. It brings major performance improvements, especially for builds with plenty of subprojects. In this blog post, we will explain what you can expect from this preview version and how the Android Studio and Gradle team achieved these improvements. Before diving into this let’s look back at what goals led to the creation of the current Android build system.&lt;/p&gt;

&lt;h2 id="the-complexity-of-mobile-development"&gt;The Complexity of Mobile Development&lt;/h2&gt;
&lt;p&gt;Developing mobile applications is inherently more complex than building traditional web or server applications of similar size. An app needs to support a wide array of devices with different peripherals, different screen sizes, and comparatively slow hardware. The popular freemium model adds another layer of variety, requiring different code paths for free and paid versions of the app. In order to provide a fast, slim app for every device and target audience, the build system needs to do a lot of the heavy lifting up front.&lt;/p&gt;

&lt;p&gt;To improve developer productivity and to reduce runtime overhead, the Android build tools provide several languages and source generators, e.g. Java, RenderScript, AIDL and Native code. Packaging an app together with its libraries involves highly customizable merging and shrinking steps. The Android Studio team was faced with the challenge of automating all of these without exposing the underlying complexity to developers. Developers can focus on writing their production code.&lt;/p&gt;

&lt;p&gt;Last but not least, developers expect a build tool to manage their dependencies, be extensible and provide deep IDE integration.&lt;/p&gt;

&lt;p&gt;Gradle is ideally suited for those challenges and the Android Studio team created a fantastic Android build tool on top of the Gradle platform.&lt;/p&gt;

&lt;h2 id="the-performance-challenge"&gt;The performance challenge&lt;/h2&gt;
&lt;p&gt;No matter how elegant and extensible the plugin and no matter how seamless the IDE integration, when things take too long, developers become unproductive and frustrated. The Android Studio team has made steady progress on performance over the last years. The emulators became much faster, the time to deploy an app decreased by orders of magnitude with Instant Run and other improvements. These steps have now exposed the build itself as the final bottleneck. The Android Studio team and the Gradle team have continuously improved the performance of the plugin and the platform, but so far this has not been enough. Fundamental design issues preventing great performance.&lt;/p&gt;

&lt;p&gt;So Gradle Inc. and Google teamed up in late 2016 to get this situation under control. The work was split up into three areas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;General improvements to Gradle and its Java support: Faster up-to-date checking,  compile avoidance, stable incremental compilation and parallel dependency downloads.&lt;/li&gt;
  &lt;li&gt;General improvements to the Android tools, like dex and code shrinking, including incremental dexing.&lt;/li&gt;
  &lt;li&gt;New APIs for variant aware dependency management in Gradle and an Android plugin that uses these new APIs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The latter allowed the Android Studio team to finally get rid of a lot of inefficient workarounds that they had to build because of these missing APIs.&lt;/p&gt;

&lt;p&gt;To understand why variant aware dependency management is so important, imagine you have an app which depends on a single library. Both of them support ARM and x86 architectures, both have a free and a paid version and both of them can be built for debug and production. This creates a total of 8 variants. But at any given point in time, a developer is only working on exactly one variant, e.g. the “free x86 debug” variant.&lt;/p&gt;

&lt;p&gt;Up until now, the Android plugin had to inspect the app’s dependencies very early in the build lifecycle to select the right variant of the library to build. This early phase is called configuration time, during which Gradle determines what tasks it needs to run in what order. More work at configuration time means slower builds no matter which tasks the user selected. It also affects how long it takes to synchronize the build with the IDE. The Android plugin’s eager dependency inspection lead to a combinatorial explosion of configuration time as more subprojects were added to a build.&lt;/p&gt;

&lt;p&gt;This completely changes with Gradle’s new variant aware dependency management. The Android plugin can now provide matching strategies for the different variant dimensions (like product flavor and build type), which Gradle uses during dependency resolution to select the correct variant of the upstream library. This completely removes the need to resolve dependencies at configuration time and also allows the Android plugin to only build the parts of the library that the app needs.&lt;/p&gt;

&lt;p&gt;In a particularly &lt;a href="https://github.com/gradle/perf-android-large/"&gt;large app&lt;/a&gt; with 130 subprojects, the time it took to configure the project dropped from 3 minutes to 10 seconds with Android 2.3 tools to under 2 seconds with Android 3.0. The clean build time dropped from over 5 minutes to about 1 minute. The effect on incremental builds is dramatic when combined with new &lt;a href="https://blog.gradle.org/incremental-compiler-avoidance"&gt;compile avoidance&lt;/a&gt; functionality. Making a single-line change and assembling the project is down to about 9 seconds. For monolithic projects these numbers won’t be as impressive, but they show that the build system now works very efficiently with modularized apps.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/android-performance.png" alt="Android performance comparison" /&gt;&lt;/p&gt;

&lt;p&gt;Last but not least, the Android Studio team is going to make the Android plugin 3.0 compatible with the &lt;a href="https://blog.gradle.org/introducing-gradle-build-cache"&gt;Gradle build cache&lt;/a&gt;. The build cache allows build outputs to be reused across clean builds and across machine boundaries. This means that developers can reuse build outputs generated by CI and build pipelines can reuse results from earlier stages. It also speeds up switching between feature branches on developer machines. Preliminary tests are promising, the clean build for the large Android app mentioned above dropped from 60s to about 20s when using the cache.&lt;/p&gt;

&lt;h2 id="give-it-a-try"&gt;Give it a try&lt;/h2&gt;

&lt;p&gt;The Android Studio team has written up a comprehensive &lt;a href="https://developer.android.com/studio/preview/features/new-android-plugin-migration.html"&gt;migration guide&lt;/a&gt;. There may be compatibility issues with community plugins, as many of them depended on internals that work differently now.&lt;/p&gt;

&lt;p&gt;If you are developing Android projects, give the preview a try and tell us how much your build times improved out of the box. Try modularizing your app a bit more and splitting &lt;code class="highlighter-rouge"&gt;api&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;implementation&lt;/code&gt; dependencies for even bigger performance gains. You can use &lt;a href="http://scans.gradle.com/"&gt;Build Scans&lt;/a&gt; and its &lt;a href="https://scans.gradle.com/s/n2hf3xwzucwny/timeline"&gt;timeline&lt;/a&gt; view to get deep insight into the performance of your build, which tasks were executed and how long they took.&lt;/p&gt;

&lt;p&gt;If you are an Android plugin author, the new version might require some changes for your plugin to stay compatible. Please &lt;a href="https://issuetracker.google.com/issues/new?component=192709&amp;amp;template=842921"&gt;file an issue&lt;/a&gt; if you encounter any problems while migrating.&lt;/p&gt;

&lt;h2 id="whats-next"&gt;What’s next?&lt;/h2&gt;
&lt;p&gt;You can expect more improvements on the Gradle side. For instance, we are currently working on parallel task execution by default.&lt;/p&gt;

&lt;p&gt;It is also safe to expect more performance smartness from the Android Studio team including Android Studio optimizations to do as little work as possible when syncing the project. The Gradle and Android Studio teams are collaborating on this as well.&lt;/p&gt;

&lt;p&gt;Support for community plugins will improve as the alpha versions mature and plugin authors adjust to it. The more people provide feedback, the faster these great improvements can be released as stable.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Introducing Gradle Build Cache Beta</title>
    <link href="https://blog.gradle.org/introducing-gradle-build-cache"/>
    <updated>2017-04-10T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/introducing-gradle-build-cache</id>
    <author>
      <name>Sterling Greene</name>
    </author>
    <content type="html">
      &lt;p&gt;Introduced in &lt;a href="https://docs.gradle.org/3.5/release-notes.html"&gt;Gradle 3.5&lt;/a&gt; to reduce build time.&lt;/p&gt;

&lt;h2 id="what-does-it-do"&gt;What does it do?&lt;/h2&gt;
&lt;p&gt;The build cache reuses the outputs of Gradle tasks locally and shares task outputs between machines. In many cases, this will accelerate the average build time.&lt;/p&gt;

&lt;p&gt;The build cache is complementary to Gradle’s incremental build features, which optimizes build performance for local changes that have not been built already. Many Gradle tasks are designed to be &lt;a href="https://blog.gradle.org/introducing-incremental-build-support"&gt;incremental&lt;/a&gt;, so that if the inputs and outputs of the task do not change, Gradle can skip the task. Even when the task’s inputs have changed, &lt;a href="https://blog.gradle.org/incremental-compiler-avoidance"&gt;some tasks&lt;/a&gt; can rebuild only the parts that have changed. Of course, these techniques only work if there are already outputs from previous local builds. In the past, building on fresh checkouts or executing “clean” builds required building everything from scratch again, even if the result of those builds had already been created locally or on another machine (such as the continuous integration server).&lt;/p&gt;

&lt;p&gt;Now, Gradle uses the inputs of a task as a key to uniquely identify the outputs for a task. With the build cache feature enabled, if Gradle can find that key in a build cache, Gradle will skip task execution and directly copy the outputs from the cache into the build directory. This can be much faster than executing the task again.&lt;/p&gt;

&lt;p&gt;In particular, if you’re using a continuous integration server, you can configure Gradle to push task outputs to a shared build cache. When a developer builds, task outputs already built on CI are copied to the developer’s machine. This can greatly improve the developer’s local build experience.&lt;/p&gt;

&lt;p&gt;When using the local build cache, instead of rebuilding large parts of the project whenever you switch branches, Gradle can skip task execution and pull the previous outputs from the local cache.&lt;/p&gt;
&lt;h2 id="how-does-it-work"&gt;How does it work?&lt;/h2&gt;
&lt;p&gt;A cacheable Gradle task is designed to declare everything that can affect the output of the task as an input. Gradle calculates a build cache key by hashing over all of the inputs to a task. That build cache key uniquely identifies the outputs of the task. This is an opt-in feature for each task implementation, so not every task is cacheable or needs to be. Several built-in Gradle tasks (&lt;code class="highlighter-rouge"&gt;JavaCompile&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;Test&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;Checkstyle&lt;/code&gt;) have caching enabled to speed up the typical Java project.&lt;/p&gt;

&lt;p&gt;The build cache key for a task takes into account:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The values of all inputs defined by the task via annotations (e.g. &lt;code class="highlighter-rouge"&gt;@InputFiles&lt;/code&gt;) or the runtime &lt;a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/TaskInputs.html"&gt;TaskInputs&lt;/a&gt; API.&lt;/li&gt;
  &lt;li&gt;The contents (and relative paths) of any file inputs.&lt;/li&gt;
  &lt;li&gt;The classpath of the task, which includes any plugins and Gradle version used.&lt;/li&gt;
  &lt;li&gt;The classpath of any task actions, which can include the build script.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When the build cache feature is enabled, Gradle will check if any of the configured build caches contain a match for the task’s build cache key when a task is not up-to-date.
If Gradle does not find a match, the task will be executed as normal. After execution, Gradle will gather all of the task’s outputs and push them to the build caches, if configured to do so.
If Gradle does find a match, the task’s outputs are deleted and the previous outputs are copied into the output directories.&lt;/p&gt;
&lt;h2 id="does-it-help"&gt;Does it help?&lt;/h2&gt;

&lt;p&gt;We have been using the build cache for the Gradle CI builds since November 2016. We also have some partners who have been trying the build cache in their builds. We can’t share their data directly, but they’ve seen similar improvements in CI and developer builds as we have. On average, we see a 25% reduction in total time spent building each commit, but some commits are even better (80% reduction) and the median build saw a 15% reduction.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/stage3-cached-vs-non-cached-pct.png" alt="Stage 3 %-Improved" /&gt;&lt;/p&gt;

&lt;p&gt;Here’s another look at the number of minutes spent between the cached and non-cached builds for Gradle.  You can see how the reductions translates into about 90 minutes saved in a 360 minute build for us.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/stage3-cached-vs-non-cached.png" alt="Stage 3 comparison" /&gt;&lt;/p&gt;

&lt;p&gt;The build cache is a generic feature that avoids re-executing a task when it can, so builds large and small can benefit in some way. The structure of your project will influence how much you can gain overall. If your project consists of a single monolithic module, Gradle has other features that may also help, such as &lt;a href="https://blog.gradle.org/incremental-compiler-avoidance"&gt;incremental compilation&lt;/a&gt; or &lt;a href="https://blog.gradle.org/introducing-composite-builds"&gt;composite builds&lt;/a&gt;. We’ll provide more information about how to get the most out of the build cache in a future blog post and at the &lt;a href="https://summit.gradle.com/session/39174"&gt;Gradle Summit&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="make-your-build-faster-today"&gt;Make your build faster today&lt;/h2&gt;
&lt;p&gt;The &lt;a href="https://docs.gradle.org/3.5/release-notes.html#faster-builds-with-the-gradle-build-cache"&gt;Gradle 3.5 release&lt;/a&gt; is the first release to include the build cache feature.&lt;/p&gt;

&lt;p&gt;We expect that the build cache feature will have general availability in the next release, but we would like for every project to give the build cache beta a try. To do that, we’d like you to try 3 things for us.&lt;/p&gt;

&lt;h3 id="1-try-it-on-a-simple-project"&gt;1) Try it on a simple project&lt;/h3&gt;
&lt;p&gt;After upgrading to 3.5, pick a simple Java project and run:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;gradle --build-cache clean assemble
gradle --build-cache clean assemble
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The second build should be faster because some task outputs are reused from the first build. These outputs will be pulled from your local build cache, which is located in a directory in your GRADLE_USER_HOME.&lt;/p&gt;

&lt;h3 id="2-try-to-share-outputs-between-machines"&gt;2) Try to share outputs between machines&lt;/h3&gt;

&lt;p&gt;To use a shared, remote cache, we provide a &lt;a href="https://github.com/gradle/gradle/tree/REL_3.5/subprojects/docs/src/samples/buildCache/developer-ci-setup"&gt;recommended configuration&lt;/a&gt; that uses your continuous integration builds to populate a shared build cache and allows all developers to pull from that build cache.&lt;/p&gt;

&lt;p&gt;You’ll need a remote build cache backend to share between developers.
We provide a &lt;a href="https://hub.docker.com/r/gradle/build-cache-node/"&gt;build cache node&lt;/a&gt; docker image which operates as a remote Gradle build cache, and can connect with &lt;a href="https://gradle.com/enterprise"&gt;Gradle Enterprise&lt;/a&gt; for centralized management.
The cache node can also be used without a Gradle Enterprise installation with restricted functionality.&lt;/p&gt;

&lt;h3 id="3-give-us-feedback"&gt;3) Give us feedback&lt;/h3&gt;

&lt;p&gt;If you have feedback, we’d love to hear it. If you have a &lt;a href="https://gradle.com/scans/get-started"&gt;build scan&lt;/a&gt; you can share, that’s even better.&lt;/p&gt;

&lt;p&gt;We’re excited to get the Gradle Build Cache feature out for feedback in Gradle 3.5, but we know there’s more we need to do to make the build cache stable and performant. We have some &lt;a href="https://docs.gradle.org/3.5/userguide/build_cache.html#sec:task_output_caching_known_issues"&gt;known issues&lt;/a&gt; that you should check before &lt;a href="https://github.com/gradle/gradle/issues/new?labels=in:build-cache"&gt;raising new issues on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;At this time, we don’t recommend that you leave the build cache enabled for production builds without understanding the risks. There are &lt;a href="https://docs.gradle.org/3.5/userguide/build_cache.html#sec:task_output_caching_known_issues"&gt;known issues&lt;/a&gt; that can cause your builds to fail or produce incorrect output, but your feedback on the types of problems or successes are very valuable to maturing the build cache feature. You can configure the build cache in your build and enable it on a trial basis by setting &lt;code class="highlighter-rouge"&gt;org.gradle.caching=true&lt;/code&gt; or running with &lt;code class="highlighter-rouge"&gt;--build-cache&lt;/code&gt; without impacting all builds.&lt;/p&gt;

&lt;p&gt;For dogfooding the build cache for Gradle, we used a separate CI job to run a build with the build cache enabled. This allowed us to compare the build times with and without the build cache for the same set of changes.&lt;/p&gt;

&lt;h3 id="thanks-and-roadmap"&gt;Thanks and roadmap&lt;/h3&gt;

&lt;p&gt;After trying the build cache, you’ll probably have some questions about why more parts of your build are not cacheable. Regardless of the build cache backend you are using, &lt;a href="https://gradle.com/enterprise/releases/2017.2"&gt;Gradle Enterprise 2017.2&lt;/a&gt; comes with features to understand build cache usage and behavior by collecting data, whether the build cache is enabled or not. Build scans keep track of the reason that a task was not cached. A task might not be cached if it has particular problems, like if it has no outputs or cacheability is not enabled for it. You can search the build scan timeline for each of these reasons.&lt;/p&gt;

&lt;p&gt;In future versions of Gradle and Gradle Enterprise, we’ll collect more information related to the build cache and task cacheability, to make it easier to diagnose build failures or poor build cache performance.&lt;/p&gt;

&lt;p&gt;For the next release, Gradle 4.0, we intend to focus on making the build cache safe to enable for all well behaved builds and providing feedback for situations where Gradle cannot safely cache outputs from a task.  This also means we’ll be providing a well-behaved local build cache and several validation checks.&lt;/p&gt;

&lt;p&gt;For the releases following that, we intend to spend time on expanding our documentation and &lt;a href="https://guides.gradle.org"&gt;Gradle guides&lt;/a&gt; to make it easier for you to cache more tasks and develop cache-friendly tasks.&lt;/p&gt;

&lt;p&gt;Thanks for your continued help and support. Please consider &lt;a href="#make-your-build-faster-today"&gt;making your build faster&lt;/a&gt; with the build cache with the three steps we outline above.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Announcing Gradle Enterprise 2017.1</title>
    <link href="https://blog.gradle.org/announcing-gradle-enterprise-2017.1"/>
    <updated>2017-03-08T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/announcing-gradle-enterprise-2017.1</id>
    <author>
      <name>Craig Atkinson</name>
    </author>
    <content type="html">
      &lt;p&gt;We are excited to announce the release of Gradle Enterprise 2017.1. This release includes many new features and bug fixes, further expanding the build insights that build scans provide you and your team. Here are some of the highlights of this release. &lt;a href="https://gradle.com/contact-us"&gt;Contact us&lt;/a&gt; if you’re interested in a demo or a trial.&lt;/p&gt;

&lt;h2 id="easily-find-changes-to-dependencies-between-two-builds"&gt;Easily find changes to dependencies between two builds&lt;/h2&gt;

&lt;p&gt;Dependency changes between builds can be a common source of problems. For example, upgrading a version of one library can unintentionally bring in different versions of transitive dependencies into your project. In turn, these newer versions can cause you all kinds of frustration by breaking compatibility with other libraries that your project uses.&lt;/p&gt;

&lt;p&gt;The new build comparison feature allows you to quickly find dependency changes between builds, including differences in transitive dependencies.&lt;/p&gt;

&lt;p&gt;You can easily select two builds to compare:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/ge-2017-1/scan-list-comparison-selection.png" alt="Select builds for dependency comparison" /&gt;&lt;/p&gt;

&lt;p&gt;And quickly see the dependency differences between the two builds:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/ge-2017-1/dependency-comparison.png" alt="Dependency comparison" /&gt;&lt;/p&gt;

&lt;h2 id="visualize-your-builds-task-execution-with-the-timeline"&gt;Visualize your build’s task execution with the timeline&lt;/h2&gt;

&lt;p&gt;When trying to make your build faster, it can be really helpful to know whether all processes are utilized efficiently. Are there optimization opportunities such as long-running tasks that could be split into smaller tasks and run in parallel? To find these optimization opportunities you first need to identify where the bottlenecks are in your build.&lt;/p&gt;

&lt;p&gt;The new timeline feature gives you a visual representation of the tasks executed during your build. Using this visualization you can quickly identify bottleneck tasks in your build, places in your build where you could speed up execution by running more tasks in parallel, and other optimization opportunities.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/ge-2017-1/timeline.jpg" alt="Timeline" /&gt;&lt;/p&gt;

&lt;p&gt;You can also filter tasks by name/path, type and more, making it easy to inspect and highlight particular tasks.&lt;/p&gt;

&lt;p&gt;Try out the timeline with &lt;a href="https://scans.gradle.com/s/cqimzwzs3nflg/timeline" target="_blank"&gt;this example scan&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="view-dependency-downloads"&gt;View dependency downloads&lt;/h2&gt;

&lt;p&gt;Time spent downloading dependencies can have a significant impact on your build time. The new “Network Activity” tab in the “Performance” section shows all the downloads triggered by dependency resolution in your build, including the size of each download and how long it took.&lt;/p&gt;

&lt;p&gt;You can identify big or slow downloads that are dragging down your build speed. Are there downloads from slow remote repositories that you could cache on-site? Or large downloads that are no longer needed in your build and could be removed entirely?&lt;/p&gt;

&lt;p&gt;Also, you can see the overall number of downloads in your build, total download size, and average download speed across the downloads to quickly gauge overall network performance during your build.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/ge-2017-1/network-activity.png" alt="Network activity" /&gt;&lt;/p&gt;

&lt;p&gt;This feature requires the upcoming Gradle version 3.5 and build scan plugin 1.6 or later.&lt;/p&gt;

&lt;p&gt;See network activity on &lt;a href="https://scans.gradle.com/s/w7uodh22pjiam/performance/networkActivity" target="_blank"&gt;this example scan&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="integrate-your-build-data-with-other-systems"&gt;Integrate your build data with other systems&lt;/h2&gt;
&lt;p&gt;The new Export API provides a mechanism for consuming the raw build data that powers build scans. It is a HTTP interface based on Server Sent Events (SSE) that supports real time data integration. Libraries for consuming SSE streams are available for most programming languages.&lt;/p&gt;

&lt;p&gt;The video below demonstrates a real time build duration dashboard built on the Export API. The code for this is available as part of the &lt;a href="https://github.com/gradle/gradle-enterprise-export-api-samples" target="_blank"&gt;gradle-enterprise-export-api-samples&lt;/a&gt; repository on GitHub.&lt;/p&gt;

&lt;iframe src="https://player.vimeo.com/video/202944447" width="660" height="372" frameborder="0" title="Gradle Enterprise - Export API" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""&gt;
&lt;/iframe&gt;

&lt;h2 id="see-why-a-task-wasnt-cacheable"&gt;See why a task wasn’t cacheable&lt;/h2&gt;
&lt;p&gt;Gradle 3.3 introduced the build cache feature, which saves you time by reusing task outputs from other builds without needing to execute the task on your machine. For a given task to use the build cache, certain conditions must be met. Gradle Enterprise now indicates which tasks are cacheable and not cacheable.&lt;/p&gt;

&lt;p&gt;To give you the opportunity to make more tasks cacheable and improve your build performance, you can see the reasons why tasks were not cacheable. The “Settings and Suggestions” tab of the “Performance” section now indicates if there were tasks that were not cacheable.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/ge-2017-1/not-cacheable-tasks-suggestion.png" alt="Not-cacheable tasks suggestion" /&gt;&lt;/p&gt;

&lt;p&gt;And in the new timeline view you can search for cacheable and non-cacheable tasks as well as see why individual tasks were not cacheable.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/ge-2017-1/not-cacheable-task.png" alt="Not-cacheable task" /&gt;&lt;/p&gt;

&lt;p&gt;This feature requires Gradle version 3.4 and build scan plugin 1.6 or later.&lt;/p&gt;

&lt;p&gt;Try it out with &lt;a href="https://scans.gradle.com/s/cqimzwzs3nflg/performance/suggestions" target="_blank"&gt;this example scan&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="better-understand-task-performance"&gt;Better understand task performance&lt;/h2&gt;
&lt;p&gt;Gradle can save you build time by not re-executing tasks that don’t need to be executed again. For example, tasks that are already up-to-date, or where the outputs can be pulled from the build cache.&lt;/p&gt;

&lt;p&gt;The “Task Execution” tab of the “Performance” section summarizes which tasks were executed and which were avoided. The summary gives you an understanding how well cacheable your build currently is, making it easier for you to find optimization opportunities by tuning tasks to make them cacheable. You can also click from the summary into the timeline to see all tasks in a particular category.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/ge-2017-1/task-execution-breakdown.png" alt="Task execution breakdown" /&gt;&lt;/p&gt;

&lt;p&gt;Try it out with &lt;a href="https://scans.gradle.com/s/ynmchyv645uiw/performance/execution" target="_blank"&gt;this example scan&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="find-builds-by-absence-of-a-tag"&gt;Find builds by absence of a tag&lt;/h2&gt;
&lt;p&gt;You can annotate a build scan with one or more tags to easily categorize the build. For example, to indicate which builds were executed on your continuous integration server.&lt;/p&gt;

&lt;p&gt;Previously you could find scans that had one or more specific tags, and now you can also do the inverse - find scans that don’t have a specific tag. To do that, use the &lt;code class="highlighter-rouge"&gt;not:&lt;/code&gt; prefix when searching tags. For example, if you tag all of your continuous integration builds with the “CI” tag, you can find all non-CI builds by searching &lt;code class="highlighter-rouge"&gt;not:CI&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/ge-2017-1/negative-tag-filtering.png" alt="Negative tag filtering" /&gt;&lt;/p&gt;

&lt;p&gt;Please see this &lt;a href="https://blog.gradle.org/custom-data-in-build-scans" target="_blank"&gt;Custom Data in Build Scans&lt;/a&gt; post for more about how and when to use tags.&lt;/p&gt;

&lt;h2 id="find-builds-faster"&gt;Find builds faster&lt;/h2&gt;
&lt;p&gt;Gradle Enterprise gives you the ability to find exactly the builds you need by filtering builds by project name, start time, outcome, and more. With the latest release, searching for build scans is now much faster - especially when you are searching through a large number of builds. This makes it faster to find exactly the builds you are looking for.&lt;/p&gt;

&lt;h2 id="try-it-today"&gt;Try it today!&lt;/h2&gt;
&lt;p&gt;We hope you are as excited as we are about these great new features. &lt;a href="https://gradle.com/contact-us"&gt;Contact us&lt;/a&gt; today for a trial! You can also &lt;a href="https://gradle.com/enterprise/releases/2017.1"&gt;check out the release notes&lt;/a&gt; to see what else is new.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Incremental Compilation, the Java Library Plugin, and other performance features in Gradle 3.4</title>
    <link href="https://blog.gradle.org/incremental-compiler-avoidance"/>
    <updated>2017-02-25T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/incremental-compiler-avoidance</id>
    <author>
      <name>Cédric Champeau</name>
    </author>
    <content type="html">
      &lt;p&gt;We are very proud to announce that the newly released Gradle 3.4 has significantly improved support for building Java applications, for all kind of users. This post explains in details what we fixed, improved and added. We will in particular focus on:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Extremely fast incremental builds&lt;/li&gt;
  &lt;li&gt;The end of the dreaded compile classpath leakage&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The improvements we made can dramatically improve your build times. Here’s what we measured:&lt;/p&gt;

&lt;style&gt;
#chart {
    width: 100%
}
&lt;/style&gt;

&lt;div id="chart"&gt;&lt;/div&gt;
&lt;!-- Load c3.css --&gt;
&lt;link href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css" rel="stylesheet" type="text/css" /&gt;

&lt;!-- Load d3.js and c3.js --&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.4/d3.min.js" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"&gt;&lt;/script&gt;

&lt;script&gt;
var chart = c3.generate({
    data: {
        rows: [
         ['Scenario','Maven 3.3.9','Gradle 3.3','Gradle 3.4'],
         ['Large project 1 change',20.80,13.10,1.30],
         ['Medium project 1 change',5.70,1.30,0.26],
         ['Multi project ABI-breaking change',26.80,15.80,3.30],
         ['Multi project ABI-compatible change',26.80,16.30,1.40]],
        type: 'bar',
        x: 'Scenario',
        labels: true
    },
    axis: {
        x: {
            type: 'category'
        },
        y: {
            label: 'seconds'
        }
    },
    legend: {
       position: 'right'
    }
});
&lt;/script&gt;

&lt;p&gt;The benchmarks are &lt;a href="https://github.com/gradle/performance-comparisons"&gt;public&lt;/a&gt;, and you can try them out yourself and are synthetic projects representing real world issues reported by our consumers. In particular, what matters in a continuous development process is being incremental (making a small change should never result in a long build):&lt;/p&gt;

&lt;p&gt;For those who work on a single project with lots of sources:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;changing a single file, in a big monolithic project and recompiling&lt;/li&gt;
  &lt;li&gt;changing a single file, in a medium-sized monolithic project and recompiling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For multi-project builds:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;making a change in an ABI-compatible way (change the body of a method, for example, but not method signatures) in a subproject, and recompiling&lt;/li&gt;
  &lt;li&gt;making a change in an ABI-incompatible way (change a public method signature, for example) in a subproject, and recompiling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For all those scenarios, Gradle 3.4 is &lt;em&gt;much&lt;/em&gt; faster. Let’s see how we did this.&lt;/p&gt;

&lt;h2 id="compile-avoidance-for-all"&gt;Compile avoidance for all&lt;/h2&gt;

&lt;p&gt;One of the greatest changes in Gradle 3.4 regarding Java support just comes for free: upgrade to Gradle 3.4 and benefit from &lt;em&gt;compile avoidance&lt;/em&gt;. Compile avoidance is different from incremental compilation, which we will cover later. So what does it mean? It’s actually very simple. Imagine that your project &lt;code class="highlighter-rouge"&gt;app&lt;/code&gt; depends on project &lt;code class="highlighter-rouge"&gt;core&lt;/code&gt;, which itself depends on project &lt;code class="highlighter-rouge"&gt;utils&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;In &lt;code class="highlighter-rouge"&gt;app&lt;/code&gt;:&lt;/p&gt;

&lt;div class="language-java highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;WordCount&lt;/span&gt; &lt;span class="n"&gt;wc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;WordCount&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;wc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;collect&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Word count: "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;wc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;wordCount&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In &lt;code class="highlighter-rouge"&gt;core&lt;/code&gt;:&lt;/p&gt;

&lt;div class="language-java highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;WordCount&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// WordCount lives in project `core`&lt;/span&gt;
   &lt;span class="c1"&gt;// ...&lt;/span&gt;
   &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;collect&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;IOUtils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;eachLine&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nl"&gt;WordCount:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;collectLine&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In &lt;code class="highlighter-rouge"&gt;utils&lt;/code&gt;:&lt;/p&gt;

&lt;div class="language-java highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;IOUtils&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// IOUtils lives in project `utils`&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;eachLine&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Callable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BufferedReader&lt;/span&gt; &lt;span class="n"&gt;reader&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BufferedReader&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FileReader&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IOException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, change the implementation of &lt;code class="highlighter-rouge"&gt;IOUtils&lt;/code&gt;. For example, change the body of &lt;code class="highlighter-rouge"&gt;eachLine&lt;/code&gt; to introduce the expected charset:&lt;/p&gt;

&lt;div class="language-java highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;IOUtils&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// IOUtils lives in project `utils`&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;eachLine&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Callable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BufferedReader&lt;/span&gt; &lt;span class="n"&gt;reader&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BufferedReader&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;InputStreamReader&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FileInputStream&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="s"&gt;"utf-8"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IOException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now rebuild &lt;code class="highlighter-rouge"&gt;app&lt;/code&gt;. What happens? Until now, &lt;code class="highlighter-rouge"&gt;utils&lt;/code&gt; had to be recompiled, but then it also triggered the recompilation of &lt;code class="highlighter-rouge"&gt;core&lt;/code&gt; and eventually &lt;code class="highlighter-rouge"&gt;app&lt;/code&gt;, because of the dependency chain. It sounds reasonable at first glance, but is it really?&lt;/p&gt;

&lt;p&gt;What changed in &lt;code class="highlighter-rouge"&gt;IOUtils&lt;/code&gt; is purely an internal detail. The implementation of &lt;code class="highlighter-rouge"&gt;eachLine&lt;/code&gt; changed, but its public API didn’t. Any class file previously compiled against &lt;code class="highlighter-rouge"&gt;IOUtils&lt;/code&gt; is still valid. Gradle is now smart enough to realize that. This means that if you make such a change, Gradle will only recompile &lt;code class="highlighter-rouge"&gt;utils&lt;/code&gt;, and nothing else! And while this example may sound simple, it’s actually a very common pattern: typically, a &lt;code class="highlighter-rouge"&gt;core&lt;/code&gt; project is shared by many subprojects, and each subproject has dependencies on different subprojects. A change to &lt;code class="highlighter-rouge"&gt;core&lt;/code&gt; would trigger a recompilation of all projects. With Gradle 3.4 this will no longer be the case, meaning that it recognizes ABI (&lt;em&gt;Application Binary Interface&lt;/em&gt;) breaking changes, and will trigger recompilation only in that case.&lt;/p&gt;

&lt;p&gt;This is what we call compilation avoidance. But even in the case when the compilation can not be avoided, Gradle 3.4 will make things much faster with the help of incremental compile.&lt;/p&gt;

&lt;h2 id="improved-incremental-compilation"&gt;Improved incremental compilation&lt;/h2&gt;

&lt;p&gt;For years, Gradle has supported an experimental incremental compiler for Java. In Gradle 3.4, not only is this compiler stable, but we also have significantly improved both its robustness and performance! Use it now: we’re going to make it the default soon! To enable Java incremental compilation, all you need to do is to set it on the compile options:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;tasks&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;withType&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JavaCompile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;incremental&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;span class="c1"&gt;// one flag, and things will get MUCH faster&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we add the following class in project &lt;code class="highlighter-rouge"&gt;core&lt;/code&gt;:&lt;/p&gt;

&lt;div class="language-java highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;NGrams&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// NGrams lives in project `core`&lt;/span&gt;
   &lt;span class="c1"&gt;// ...&lt;/span&gt;
   &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;collect&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ngramLength&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;collectInternal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StringUtils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sanitize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="n"&gt;ngramLength&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and this class in project &lt;code class="highlighter-rouge"&gt;utils&lt;/code&gt;:&lt;/p&gt;

&lt;div class="language-java highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StringUtils&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;sanitize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;dirtyString&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Imagine that we change the class &lt;code class="highlighter-rouge"&gt;StringUtils&lt;/code&gt; and recompile our project. can easily see that we only need to recompile &lt;code class="highlighter-rouge"&gt;StringUtils&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;NGrams&lt;/code&gt; but not &lt;code class="highlighter-rouge"&gt;WordCount&lt;/code&gt;. &lt;code class="highlighter-rouge"&gt;NGrams&lt;/code&gt; is a dependent class of &lt;code class="highlighter-rouge"&gt;StringUtils&lt;/code&gt;. &lt;code class="highlighter-rouge"&gt;WordCount&lt;/code&gt; doesn’t use &lt;code class="highlighter-rouge"&gt;StringUtils&lt;/code&gt;, so why would it need to be recompiled? This is what the incremental compiler does: it analyzes the dependencies between classes, and only recompiles a class when it has changed, or one of the classes it depends on has changed.&lt;/p&gt;

&lt;p&gt;Those of you who have already tried the incremental Java compiler before may have seen that it wasn’t very smart when a changed class contained a constant. For example, this class contains a constant:&lt;/p&gt;

&lt;div class="language-java highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SomeClass&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;MAGIC_NUMBER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If this class was changed, then Gradle gave up and recompiled not just all the classes of that project but also all the classes in projects that depend on that project. If you wonder why, you have to understand that the Java compiler inlines constants like this. So when we analyze the result of compilation, and that the bytecode of a class contains the &lt;em&gt;literal&lt;/em&gt; 123, we have no idea where the literal was defined. It could be in the class itself, or a constant of any dependency found anywhere on its classpath. In Gradle 3.4, we made that behavior much smarter, and only recompile classes which could &lt;em&gt;potentially&lt;/em&gt; be affected by the change. In other words, if the class is changed, but the constant is not, we don’t need to recompile. Similarly, if the constant is changed, but that the dependents didn’t have a literal in their bytecode of the old value, we don’t need to recompile them: we would only recompile the classes that have &lt;em&gt;candidate literals&lt;/em&gt;. This also means that not all constants are born equal: a constant value of &lt;code class="highlighter-rouge"&gt;0&lt;/code&gt; is much more likely to trigger a full recompilation when changed, than a constant value &lt;code class="highlighter-rouge"&gt;188847774&lt;/code&gt;…&lt;/p&gt;

&lt;p&gt;Our incremental compiler is also now backed with in-memory caches that live in the Gradle daemon across builds, and thus make it significantly faster than it used to be: extracting the ABI of a Java class is an expensive operation that used to be cached, but on disk only.&lt;/p&gt;

&lt;p&gt;If you combine all those incremental compilation improvements with the &lt;em&gt;compile avoidance&lt;/em&gt; that we described earlier in this post, Gradle is now really fast when recompiling Java code. Even better, it also works for external dependencies. Imagine that you upgrade from &lt;code class="highlighter-rouge"&gt;foo-1.0.0&lt;/code&gt; to &lt;code class="highlighter-rouge"&gt;foo-1.0.1&lt;/code&gt;. If the only difference between the two versions of the library is, for example, a bugfix, and that the API hasn’t changed, compile avoidance will kick in and this change in an external dependency will not trigger a recompile of your code. If the new version of the external dependency has a modified public API, Gradle’s incremental compiler will analyze the dependencies of your project on &lt;em&gt;individual&lt;/em&gt; classes of the external dependency, and only recompile where necessary.&lt;/p&gt;

&lt;h2 id="about-annotation-processors"&gt;About annotation processors&lt;/h2&gt;

&lt;p&gt;Annotation processors are a very powerful mechanism that allows generation of code just by annotating sources. Typical use cases include dependency injection (&lt;a href="https://google.github.io/dagger/"&gt;Dagger&lt;/a&gt;) or boilerplate code reduction (&lt;a href="https://projectlombok.org/"&gt;Lombok&lt;/a&gt;, &lt;a href="https://github.com/google/auto/tree/master/value"&gt;Autovalue&lt;/a&gt;, &lt;a href="https://github.com/JakeWharton/butterknife"&gt;Butterknife&lt;/a&gt;, …). However, using annotation processors can have a very negative impact on the performance of your builds.&lt;/p&gt;

&lt;h3 id="what-does-an-annotation-processor-do"&gt;What does an annotation processor do?&lt;/h3&gt;

&lt;p&gt;Basically, an annotation processor is a Java compiler &lt;em&gt;plugin&lt;/em&gt;. It is triggered whenever the Java compiler recognizes an annotation that is handled by a processor. From the build tool point of view, it’s a black box: we don’t know what it’s going to do, in particular what files it’s going to generate, and where.&lt;/p&gt;

&lt;p&gt;Therefore whenever the annotation processor implementation changes, Gradle needs to recompile everything. That is not that bad by itself, as this probably doesn’t happen very often. But for reasons explained soon things are much worse and Gradle has to disable compile avoidance when annotation processors are not declared explicitly. But first let’s understand what’s going on.
Typically today annotation processors are added to the compile classpath.&lt;/p&gt;

&lt;p&gt;While Gradle can detect which jar contains annotation processors, what it cannot detect is which other jars in the compile classpath are used by the annotation processor implementation. They also have dependencies. That means potentially any change in the compile classpath may affect the behavior of the annotation processor in a way Gradle can not understand. Therefore any change in the compile classpath will trigger a full recompile and we are back to square one.&lt;/p&gt;

&lt;p&gt;But there is a solution to this.&lt;/p&gt;

&lt;h4 id="explicitly-declaring-the-annotation-processor-classpath"&gt;Explicitly declaring the annotation processor classpath&lt;/h4&gt;

&lt;p&gt;Should the fact that an annotation processor, which is a &lt;em&gt;compiler plugin&lt;/em&gt; that uses external dependencies, influence your compile classpath? No, the dependencies of the annotation processor should &lt;em&gt;never&lt;/em&gt; leak into your compile classpath. That’s why &lt;code class="highlighter-rouge"&gt;javac&lt;/code&gt; has a specific &lt;code class="highlighter-rouge"&gt;-processorpath&lt;/code&gt; option which is distinct from &lt;code class="highlighter-rouge"&gt;-classpath&lt;/code&gt;. Here is how you can declare this with Gradle:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;configurations&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;apt&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;dependencies&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// The dagger compiler and its transitive dependencies will only be found on annotation processing classpath&lt;/span&gt;
    &lt;span class="n"&gt;apt&lt;/span&gt; &lt;span class="s1"&gt;'com.google.dagger:dagger-compiler:2.8'&lt;/span&gt;

    &lt;span class="c1"&gt;// And we still need the Dagger annotations on the compile classpath itself&lt;/span&gt;
    &lt;span class="n"&gt;compileOnly&lt;/span&gt; &lt;span class="s1"&gt;'com.google.dagger:dagger:2.8'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;compileJava&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;annotationProcessorPath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;configurations&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;apt&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, we’re creating a configuration, &lt;code class="highlighter-rouge"&gt;apt&lt;/code&gt;, that will contain all the annotation processors we use, and therefore also their specific transitive dependencies. Then we set the &lt;code class="highlighter-rouge"&gt;annotationProcessorPath&lt;/code&gt; to this configuration. What this enables is two-fold:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;it disables automatic annotation processor detection on the compile classpath, making the task start faster (faster up-to-date checks)&lt;/li&gt;
  &lt;li&gt;it will make use of the &lt;code class="highlighter-rouge"&gt;processorpath&lt;/code&gt; option of the Java compiler, and properly separate compile dependencies from the annotation processing path&lt;/li&gt;
  &lt;li&gt;it will enable &lt;strong&gt;compile avoidance&lt;/strong&gt; : by explicitly saying that you use annotation processors, we can now make sure that everything that is found on classpath is only binary interfaces&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In particular, you will notice how &lt;a href="https://google.github.io/dagger/"&gt;Dagger&lt;/a&gt; cleanly separates its compiler from its annotations: we have &lt;code class="highlighter-rouge"&gt;dagger-compiler&lt;/code&gt; as an annotation processing dependency, and &lt;code class="highlighter-rouge"&gt;dagger&lt;/code&gt; (the annotations themselves) as &lt;code class="highlighter-rouge"&gt;compile&lt;/code&gt; dependencies. For Lombok, you would typically have to put the same dependency both in &lt;code class="highlighter-rouge"&gt;compile&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;apt&lt;/code&gt; to benefit from compile avoidance again.&lt;/p&gt;

&lt;p&gt;However, some annotation processors do not separate these concerns properly and thus leak their implementation classes onto your classpath. Compile avoidance still works in this scenario: you need just put the jar on both the &lt;code class="highlighter-rouge"&gt;apt&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;compileOnly&lt;/code&gt; configurations.&lt;/p&gt;

&lt;h4 id="incremental-compile-with-annotation-processors"&gt;Incremental compile with annotation processors&lt;/h4&gt;

&lt;p&gt;As said above, with annotation processors, Gradle does not know which files they are going to generate. Neither does it know where and based on what conditions. Therefore Grade disables the Java incremental compiler if annotation processors are in use, even if you declare them explicitly as we just have done. It is however possible to limit the impact of this to the set of classes that really use annotation processors. In short, you can declare a different source set, with a different compile task, that will use the annotation processor, and leave the other compile tasks without any kind of annotation processing: any change to a class that doesn’t use annotation processors would therefore benefit from incremental compilation, whereas any change to the sources that use annotations would trigger a full recompilation, but of that source set only. Here’s an example how to do it:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;configurations&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;apt&lt;/span&gt;
    &lt;span class="n"&gt;aptCompile&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;dependencies&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;apt&lt;/span&gt; &lt;span class="s1"&gt;'com.google.dagger:dagger-compiler:2.8'&lt;/span&gt;
    &lt;span class="n"&gt;aptCompile&lt;/span&gt; &lt;span class="s1"&gt;'com.google.dagger:dagger:2.8'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;sourceSets&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;processed&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;java&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;compileClasspath&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;configurations&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;aptCompile&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;java&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;compileClasspath&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;processed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;output&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;compileProcessedJava&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;annotationProcessorPath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;configurations&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;apt&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In practice this may not be an easy split to perform, dependending on how much the &lt;code class="highlighter-rouge"&gt;main&lt;/code&gt; sources depend on classes found in the &lt;code class="highlighter-rouge"&gt;processed&lt;/code&gt; classes.
We are, however, exploring options to enable incremental compilation when annotation processors are present, which means that this shouldn’t be an issue in the future.&lt;/p&gt;

&lt;h2 id="java-libraries"&gt;Java libraries&lt;/h2&gt;

&lt;p&gt;We at Gradle have been explaining for a long time why the Maven dependency model is broken, but it’s often hard to realize without a concrete example, because users just get used to the defect and deal with it as if it was natural. In particular, the &lt;code class="highlighter-rouge"&gt;pom.xml&lt;/code&gt; file is used both for building a component and for its publication metadata. Gradle has always worked differently, by having build scripts which are the “recipe” to build a component, and publications, which can be done to Maven, Ivy, or whatever other repositories you need to support. The publication contains metadata about how to consume the project, meaning that we clearly separate what you need to build a component from what you need as its consumer. Separating the two roles is extremely important, and it allows Gradle 3.4 to add a fundamental improvement to Java dependency management. There are multiple benefits you get with this new feature. One is better performance, as it complements the other performance features we have described above, but there are more.&lt;/p&gt;

&lt;h3 id="weve-all-been-doing-it-wrong"&gt;We’ve all been doing it wrong&lt;/h3&gt;

&lt;p&gt;When building a Java project, there are two things being considered:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;what do I need to compile the project itself?&lt;/li&gt;
  &lt;li&gt;what do I need at runtime to execute the project?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Which drives us naturally to declaring dependencies in two distinct scopes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;compile&lt;/code&gt; : the dependencies I need to compile the project&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;runtime&lt;/code&gt; : the dependencies I need to run the project&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Maven and Gradle have both been using this for years. But since the beginning, we knew we were wrong. This view is over simplistic, because it doesn’t consider the &lt;em&gt;consumers&lt;/em&gt; of your project. In particular, there are (at least) two kinds of projects in the Java world:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;applications, which are standalone, executable, and don’t expose any API&lt;/li&gt;
  &lt;li&gt;libraries, which are used by other libraries, or other applications, as bricks to build software, and therefore expose an API&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The problem with the simplistic approach of having two configurations (Gradle) or scopes (Maven) is that you don’t consider what is required in your API versus what is required by your implementation. In other words, you are &lt;strong&gt;leaking the compile dependencies of your component to downstream consumers&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Imagine that we are building an IoT application &lt;code class="highlighter-rouge"&gt;home-automation&lt;/code&gt; which depends on a &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt; library that has &lt;code class="highlighter-rouge"&gt;commons-math3.jar&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;guava.jar&lt;/code&gt; on its compile classpath. Then the compile classpath of &lt;code class="highlighter-rouge"&gt;home-automation&lt;/code&gt; will include &lt;code class="highlighter-rouge"&gt;commons-math3.jar&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;guava.jar&lt;/code&gt;. There are several consequences to this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;home-automation&lt;/code&gt; may start using classes from &lt;code class="highlighter-rouge"&gt;commons-math3.jar&lt;/code&gt; or &lt;code class="highlighter-rouge"&gt;guava.jar&lt;/code&gt; without really realizing they are transitive dependencies of &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt; (transitive dependency leakage).&lt;/li&gt;
  &lt;li&gt;the compile classpath of &lt;code class="highlighter-rouge"&gt;home-automation&lt;/code&gt; is bigger:
    &lt;ul&gt;
      &lt;li&gt;this increases the time spend on dependency resolution, up-to-date checking, classpath analysis and &lt;code class="highlighter-rouge"&gt;javac&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;the new Gradle compile avoidance will be less efficient because changes in the classpath are more likely to happen and compile avoidance will not kick in. Specially, when you are using annotation processors where Gradle incremental compile is disabled, this comes with a high cost.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;you are increasing the chances of dependency hell (different versions of the same dependency on classpath)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But the worst issue is that if the usage of &lt;code class="highlighter-rouge"&gt;guava.jar&lt;/code&gt; is a purely internal detail for &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt;, and that &lt;code class="highlighter-rouge"&gt;home-automation&lt;/code&gt; starts using it because it was found on classpath, then it becomes very hard to evolve &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt; because it would break consumers. The leakage of dependencies is a dreaded issue that leads to slowly evolving software and feature freeze, for the sake of backwards compatibility.&lt;/p&gt;

&lt;p&gt;We know we’ve been doing this wrong, it’s time to fix it, and introduce the new Java Library plugin!&lt;/p&gt;

&lt;h3 id="introducing-the-java-library-plugin"&gt;Introducing the Java Library plugin&lt;/h3&gt;

&lt;p&gt;Starting from Gradle 3.4, if you build a Java library, that is to say a component aimed at being consumed by other components (a component that is a dependency of another), then you should use the new Java Library plugin. Instead of writing:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;apply&lt;/span&gt; &lt;span class="nl"&gt;plugin:&lt;/span&gt; &lt;span class="s1"&gt;'java'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;use:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;apply&lt;/span&gt; &lt;span class="nl"&gt;plugin:&lt;/span&gt; &lt;span class="s1"&gt;'java-library'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;They both share a common infrastructure, but the &lt;code class="highlighter-rouge"&gt;java-library&lt;/code&gt; plugin exposes the concept of an API. Let’s migrate our &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt; library, which itself has 2 dependencies:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;dependencies&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;compile&lt;/span&gt; &lt;span class="s1"&gt;'org.apache.commons:commons-math3:3.6.1'&lt;/span&gt;
   &lt;span class="n"&gt;compile&lt;/span&gt; &lt;span class="s1"&gt;'com.google.guava:guava:21.0'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When you study the code in &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt;, you understand that &lt;code class="highlighter-rouge"&gt;commons-math3&lt;/code&gt; is exposed in the public API, while &lt;code class="highlighter-rouge"&gt;guava&lt;/code&gt; is purely internal:&lt;/p&gt;

&lt;div class="language-java highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.google.common.collect.Lists&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.apache.commons.math3.stat.descriptive.SummaryStatistics&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HeatSensor&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;SummaryStatistics&lt;/span&gt; &lt;span class="nf"&gt;getMeasures&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lastHours&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
         &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Measurement&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;measures&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Lists&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;newArrayList&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Google Guava is used internally, but doesn't leak into the public API&lt;/span&gt;
         &lt;span class="c1"&gt;// ...&lt;/span&gt;
         &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;stats&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It means that if tomorrow, &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt; wants to switch from Guava to another collections library, it can do it without any impact to its consumers. But in practice, it’s only possible if we cleanly separate those dependencies into 2 buckets:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;dependencies&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;api&lt;/span&gt; &lt;span class="s1"&gt;'org.apache.commons:commons-math3:3.6.1'&lt;/span&gt;
   &lt;span class="n"&gt;implementation&lt;/span&gt; &lt;span class="s1"&gt;'com.google.guava:guava:21.0'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class="highlighter-rouge"&gt;api&lt;/code&gt; bucket is used to declare dependencies that should transitively be visible by downstream consumers when they are compiled. The &lt;code class="highlighter-rouge"&gt;implementation&lt;/code&gt; bucket is used to declare dependencies which should not leak into the compile classpath of consumers (because they are purely internal details).&lt;/p&gt;

&lt;p&gt;Now, when a consumer of &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt; is going to be compiled, it will &lt;strong&gt;only&lt;/strong&gt; find &lt;code class="highlighter-rouge"&gt;commons-math3.jar&lt;/code&gt; on compile classpath, not &lt;code class="highlighter-rouge"&gt;guava.jar&lt;/code&gt;. So if &lt;code class="highlighter-rouge"&gt;home-automation&lt;/code&gt; accidently tries to use a class from Google Guava, it will fail at compile time, and the consumer needs to decide whether it really wants to introduce Guava as a dependency or not. On the other hand, if it tries to use a class from Apache Math3, which is an API dependency, then will succeed, because API dependencies are absolutely required at compile time.&lt;/p&gt;

&lt;h3 id="better-poms-than-maven"&gt;Better POMs than Maven&lt;/h3&gt;

&lt;p&gt;So when does &lt;code class="highlighter-rouge"&gt;implementation&lt;/code&gt; matter? It matters at runtime only! This is why, now, the &lt;code class="highlighter-rouge"&gt;pom.xml&lt;/code&gt; file that Gradle generates whenever you choose to publish on a Maven repository is cleaner than what Maven can offer! Let’s look at what we generate for &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt;, using the &lt;code class="highlighter-rouge"&gt;maven-publish&lt;/code&gt; plugin:&lt;/p&gt;

&lt;div class="language-xml highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;project&lt;/span&gt; &lt;span class="na"&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class="s"&gt;"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;"http://maven.apache.org/POM/4.0.0"&lt;/span&gt;
    &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;"http://www.w3.org/2001/XMLSchema-instance"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.acme&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;heat-sensor&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.commons&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;commons-math3&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.6.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;compile&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.google.guava&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;guava&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;21.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;runtime&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What you see is the &lt;code class="highlighter-rouge"&gt;pom.xml&lt;/code&gt; file that is published, and therefore &lt;em&gt;used by consumers&lt;/em&gt;. And what does it say?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;to &lt;em&gt;compile&lt;/em&gt; against &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt;, you need &lt;code class="highlighter-rouge"&gt;commons-math3&lt;/code&gt; on &lt;code class="highlighter-rouge"&gt;compile&lt;/code&gt; classpath&lt;/li&gt;
  &lt;li&gt;to &lt;em&gt;run&lt;/em&gt; against &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt;, you need &lt;code class="highlighter-rouge"&gt;guava&lt;/code&gt; on &lt;code class="highlighter-rouge"&gt;runtime&lt;/code&gt; classpath&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is &lt;strong&gt;very&lt;/strong&gt; different from having the same &lt;code class="highlighter-rouge"&gt;pom.xml&lt;/code&gt; for both compiling the component and consuming it. Because to compile &lt;code class="highlighter-rouge"&gt;heat-sensor&lt;/code&gt; itself, you would need &lt;code class="highlighter-rouge"&gt;guava&lt;/code&gt; in &lt;code class="highlighter-rouge"&gt;compile&lt;/code&gt;. In short: Gradle generates better POM files than Maven, because it makes the difference between the producer and the consumer.&lt;/p&gt;

&lt;h3 id="more-uses-cases-more-configurations"&gt;More uses cases, more configurations&lt;/h3&gt;

&lt;p&gt;You might be aware of the &lt;code class="highlighter-rouge"&gt;compileOnly&lt;/code&gt; configuration that &lt;a href="https://blog.gradle.org/introducing-compile-only-dependencies"&gt;was introduced in Gradle 2.12&lt;/a&gt;, which can be used to declare dependencies which are only required when compiling a component, but not at runtime (a typical use case is libraries which are embedded into a fat jar or &lt;a href="https://github.com/johnrengelman/shadow"&gt;shadowed&lt;/a&gt;). The &lt;code class="highlighter-rouge"&gt;java-library&lt;/code&gt; plugin provides a smooth migration path from the &lt;code class="highlighter-rouge"&gt;java&lt;/code&gt; plugin: if you are building an application, you can continue to use the &lt;code class="highlighter-rouge"&gt;java&lt;/code&gt; plugin. Otherwise, if it’s a library, just use the &lt;code class="highlighter-rouge"&gt;java-library&lt;/code&gt; plugin. But in both cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;instead of the &lt;code class="highlighter-rouge"&gt;compile&lt;/code&gt; configuration, you should use &lt;code class="highlighter-rouge"&gt;implementation&lt;/code&gt; instead&lt;/li&gt;
  &lt;li&gt;instead of the &lt;code class="highlighter-rouge"&gt;runtime&lt;/code&gt; configuration, you should use &lt;code class="highlighter-rouge"&gt;runtimeOnly&lt;/code&gt; configuration to declare dependencies which should only be visible at runtime&lt;/li&gt;
  &lt;li&gt;to resolve the runtime of a component, use &lt;code class="highlighter-rouge"&gt;runtimeClasspath&lt;/code&gt; instead of &lt;code class="highlighter-rouge"&gt;runtime&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="impact-on-performance"&gt;Impact on performance&lt;/h3&gt;

&lt;p&gt;To show you what the impact on performance can be, we added a benchmark which compares two scenarios:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;making an ABI-compatible change in a library, then recompile&lt;/li&gt;
  &lt;li&gt;making an ABI-incompatible change in a library, then recompile&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Only Gradle 3.4 supports the concept of library, and therefore uses the Java Library Plugin. And to make it even clearer, this benchmark does &lt;em&gt;not&lt;/em&gt; use the incremental compiler (which would make things even faster, updates would almost be a no-op):&lt;/p&gt;

&lt;style&gt;
#chart2 {
    width: 100%
}
&lt;/style&gt;

&lt;div id="chart2"&gt;&lt;/div&gt;
&lt;script&gt;
var chart2 = c3.generate({
    bindto: '#chart2',
    data: {
        rows: [
         ['Scenario','Maven 3.3.9','Gradle 3.3','Gradle 3.4'],
         ['Library ABI-breaking change',10.60,3.80,2.60],
         ['Library ABI-compatible change',10.80,3.90,1.50]],
        type: 'bar',
        x: 'Scenario',
        labels: true
    },
    axis: {
        x: {
            type: 'category'
        },
        y: {
            label: 'seconds'
        }
    },
    legend: {
       position: 'right'
    }
});
&lt;/script&gt;

&lt;p&gt;As you can see, in addition to better modelling, there’s a strong impact on performance!&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Gradle 3.4 brings dramatic improvements to the Java ecosystem. Better incremental compilation and compile avoidance will significantly improve your productivity, while clean separation of API and implementation dependencies will avoid accidental leakage of dependencies and help you better model your software. Note that we have more goodness to come. In particular, separation of API and implementation is key to Java 9 success, with the awakening of &lt;a href="http://openjdk.java.net/projects/jigsaw/"&gt;Project Jigsaw&lt;/a&gt;. We’re going to add a way to declare what &lt;em&gt;packages&lt;/em&gt; belong to your API, making it even closer to what Jigsaw will offer, but supported on older JDKs too.&lt;/p&gt;

&lt;p&gt;In addition, Gradle 4.0 will ship with a build cache, which will strongly benefit from the improvements described in this post: it’s a mechanism which allows reusing, and sharing, the result of execution of tasks on a local machine or over the network. Typical use cases include switching branches, or simply checking out a project which has already been built by a colleague or on CI. Said differently, if you, or someone else, has already built something you need, you would get it from the cache instead of having to build it locally. For this, the build cache needs to generate a cache key which is, for java compile task, typically sensitive to the compile classpath. The improvements that ship in 3.4 will make this cache key more likely to be hit, because we would ignore what is not relevant to consumers (only ABI matters).&lt;/p&gt;

&lt;p&gt;We encourage you to upgrade now, take a look at the &lt;a href="https://docs.gradle.org/current/userguide/java_library_plugin.html"&gt;documentation of the new Java Library plugin&lt;/a&gt; and discover all it can do for you!&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Announcing Buildship 2.0</title>
    <link href="https://blog.gradle.org/announcing-buildship-2.0"/>
    <updated>2017-01-11T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/announcing-buildship-2.0</id>
    <author>
      <name>Donat Csikos</name>
    </author>
    <content type="html">
      &lt;p&gt;We are pleased to announce that version 2.0 of Buildship—our official Gradle support for Eclipse—is now available via the Eclipse Marketplace. This release adds &lt;strong&gt;support for composite builds&lt;/strong&gt;, greatly reducing development turnaround time. &lt;strong&gt;The UI has been redesigned&lt;/strong&gt; based on plenty of community feedback during the 1.x line. &lt;strong&gt;Project synchronization is now more accurate&lt;/strong&gt; and &lt;strong&gt;project import requires one less step&lt;/strong&gt;. We’ve added &lt;strong&gt;support for Gradle’s offline mode&lt;/strong&gt; (thanks &lt;a href="https://github.com/rlagoue"&gt;Rodrigue&lt;/a&gt;!), and last but not least, third-party integrators can take advantage of our &lt;strong&gt;new &lt;code class="highlighter-rouge"&gt;InvocationCustomizer&lt;/code&gt; extension point&lt;/strong&gt;. Read on for details about each of these new features.&lt;/p&gt;

&lt;h2 id="composite-build-support"&gt;Composite build support&lt;/h2&gt;

&lt;h4 id="what-is-a-composite-build"&gt;What is a composite build?&lt;/h4&gt;
&lt;p&gt;The &lt;a href="https://docs.gradle.org/current/userguide/composite_builds.html"&gt;composite build&lt;/a&gt; feature in Gradle allows you to handle several distinct Gradle builds as if they were one big multi-project build. This dramatically shortens the turnaround time when you need to work on several projects that are normally developed separately.&lt;/p&gt;

&lt;p&gt;Let’s assume you have written a Java library &lt;code class="highlighter-rouge"&gt;lib&lt;/code&gt;, used by many of your applications. You find a bug which only manifests itself in the &lt;code class="highlighter-rouge"&gt;special-app&lt;/code&gt;. The traditional development workflow would be to change some code in &lt;code class="highlighter-rouge"&gt;lib&lt;/code&gt; and install a snapshot into the local repository. Then you would have to change the build script of &lt;code class="highlighter-rouge"&gt;special-app&lt;/code&gt; to use that new snapshot and check if the bug is actually fixed.&lt;/p&gt;

&lt;p&gt;With composite builds, however, you can tell Gradle to treat both of these projects as one. This will let &lt;code class="highlighter-rouge"&gt;special-app&lt;/code&gt; depend directly on the output of the &lt;code class="highlighter-rouge"&gt;lib&lt;/code&gt; project.&lt;/p&gt;

&lt;p&gt;You can learn more about composite builds in &lt;a href="/introducing-composite-builds"&gt;this introductory blog post&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id="composite-builds-in-the-ide"&gt;Composite builds in the IDE&lt;/h4&gt;
&lt;p&gt;If you develop &lt;code class="highlighter-rouge"&gt;special-app&lt;/code&gt; you probably have it imported in Eclipse with &lt;code class="highlighter-rouge"&gt;lib&lt;/code&gt; referenced as a binary dependency.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/buildship-2.0-workspace.png" alt="Buildship workspace" /&gt;&lt;/p&gt;

&lt;p&gt;There is not much difference between working with composite builds at the command line and working with them within Eclipse. To include &lt;code class="highlighter-rouge"&gt;lib&lt;/code&gt; you need only add an entry to your &lt;code class="highlighter-rouge"&gt;settings.gradle&lt;/code&gt; file, telling Gradle from which folder the additional build should be included.&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;includeBuild&lt;/span&gt; &lt;span class="s1"&gt;'../lib'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, to apply the changes right-click on the project and select &lt;code class="highlighter-rouge"&gt;Gradle &amp;gt; Refresh Project&lt;/code&gt;. After the synchronization finishes, you should see two things: the project from the included build is imported and the binary dependency is replaced with a project dependency.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/buildship-2.0-workspace-with-composite.png" alt="Imported composite" /&gt;&lt;/p&gt;

&lt;p&gt;Now, you can make changes to both projects with the benefit of complete IDE support: error markers, code completion, refactoring and more. Also, if you execute Gradle tests—or any other build task—from the &lt;code class="highlighter-rouge"&gt;Gradle Tasks&lt;/code&gt; view, the execution considers changes from the included builds.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/buildship-2.0-task-execution.png" alt="Task execution with included builds" /&gt;&lt;/p&gt;

&lt;h4 id="limitations"&gt;Limitations&lt;/h4&gt;
&lt;p&gt;When using composite builds from the IDE you should be aware of the following limitations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Composite builds support only works if the imported project uses Gradle 3.3 or above.&lt;/li&gt;
  &lt;li&gt;Task execution is disabled on included builds due to a &lt;a href="https://docs.gradle.org/current/userguide/composite_builds.html#current_limitations_and_future_work"&gt;task addressing limitation in Gradle&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Including WTP projects into a composite is not supported.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="design-overhaul"&gt;Design overhaul&lt;/h2&gt;
&lt;p&gt;We updated the Buildship user interface to align it with current Gradle branding as well as with the Eclipse design guidelines. The icons are now distinguishable by color-blind people and work well with Eclipse’s dark theme. Finally, high-definition images have been put in place for use with High-DPI displays.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/buildship-2.0-design-overhaul.png" alt="New Buildship design" /&gt;&lt;/p&gt;

&lt;h2 id="import-wizard-simplification"&gt;Import wizard simplification&lt;/h2&gt;
&lt;p&gt;We removed JAVA_HOME, program arguments, and JVM arguments configuration from the import and new project wizards. Users can still configure these properties via the &lt;a href="https://docs.gradle.org/current/userguide/build_environment.html"&gt;&lt;code class="highlighter-rouge"&gt;gradle.properties&lt;/code&gt; file&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="more-accurate-project-synchronization"&gt;More accurate project synchronization&lt;/h2&gt;
&lt;p&gt;In Buildship 1.x if the project being imported had Eclipse descriptors then a dialog was shown to determine if those descriptors should be updated or deleted. This behavior was error-prone and distracting for users.&lt;/p&gt;

&lt;p&gt;To avoid showing a dialog, we improved the project synchronization algorithm the following way: If the Gradle version used by the project can provide a specific attribute (e.g. project natures), it is completely overwritten. Manual modifications are only kept if Gradle provides no information about that attribute. This allows users of older Gradle versions to work around missing information in the model, while giving users of new Gradle versions a much more consistent experience.&lt;/p&gt;

&lt;h2 id="offline-mode-support"&gt;Offline mode support&lt;/h2&gt;
&lt;p&gt;Users can now set Buildship to work offline via the workspace preferences. Once enabled, all Gradle invocations will receive an extra &lt;code class="highlighter-rouge"&gt;--offline&lt;/code&gt; argument.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/buildship-2.0-offline-mode.png" alt="Offline mode support in preferences" /&gt;&lt;/p&gt;

&lt;h2 id="invocationcustomizer-extension-point"&gt;InvocationCustomizer extension point&lt;/h2&gt;
&lt;p&gt;The &lt;code class="highlighter-rouge"&gt;InvocationCustomizer&lt;/code&gt; extension point enables Eclipse plugins to contribute extra arguments to Gradle builds. This allows integrators to add init scripts or control project properties from the IDE. For a sample implementation check out the &lt;a href="https://github.com/eclipse/buildship/blob/master/docs/development/ApiExamples.md"&gt;Buildship documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="breaking-changes"&gt;Breaking changes&lt;/h2&gt;
&lt;p&gt;This release introduces the following breaking changes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Minimum Java version set to 1.7&lt;/li&gt;
  &lt;li&gt;Minimum Eclipse version is set to 4.2&lt;/li&gt;
  &lt;li&gt;Project renaming is disabled for projects that are located directly under the Eclipse workspace location.&lt;/li&gt;
  &lt;li&gt;Projects migrating from Eclipse Mars directly to Eclipse Oxygen need to be reimported&lt;/li&gt;
  &lt;li&gt;JAVA_HOME can no longer be configured on import, please use &lt;code class="highlighter-rouge"&gt;gradle.properties&lt;/code&gt; instead&lt;/li&gt;
  &lt;li&gt;Java arguments and Gradle properties can no longer be configured on import, please use &lt;code class="highlighter-rouge"&gt;gradle.properties&lt;/code&gt; instead&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="installation"&gt;Installation&lt;/h2&gt;
&lt;p&gt;Buildship 2.0 is available from the &lt;a href="https://marketplace.eclipse.org/content/buildship-gradle-integration"&gt;Eclipse Marketplace&lt;/a&gt; or from the &lt;a href="https://github.com/eclipse/buildship/blob/master/docs/user/Installation.md#installing-from-eclipseorg-update-site"&gt;eclipse.org&lt;/a&gt; update sites. Please note that the update site URL has changed therefore no automatic update is available for this release.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Custom Data in Build Scans</title>
    <link href="https://blog.gradle.org/custom-data-in-build-scans"/>
    <updated>2017-01-04T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/custom-data-in-build-scans</id>
    <author>
      <name>Craig Atkinson</name>
    </author>
    <content type="html">
      &lt;p&gt;Build scans are a great way to easily share data about your build, but what if your team wants to add their own data to those build scans? They can! In addition to the extensive information automatically captured in build scans, you can attach your own custom data to provide even deeper insights into your build. This custom data can take the form of tags, links, and arbitrary custom values in a key-value format.&lt;/p&gt;

&lt;p&gt;By adding custom data to your build scans you can make it easy to find builds of a certain type, give quick links to the applicable source code commit on GitHub, add helpful CI build information, and much more. Then, when you share the single build scan link with a teammate, they get quick and easy access to a plethora of information about your build, making it easier for them to diagnose build environment issues, fix test failures, and so on.&lt;/p&gt;

&lt;p&gt;If build scans are new to you, you can learn about them in our &lt;a href="https://blog.gradle.org/introducing-build-scans"&gt;introductory blog post on the topic&lt;/a&gt;. You can also find more details in the &lt;a href="https://docs.gradle.com/scans/"&gt;Build Scans User Manual&lt;/a&gt;, &lt;a href="https://gradle.com/#explore"&gt;explore some example build scans&lt;/a&gt; or &lt;a href="https://github.com/gradle/gradle-build-scan-quickstart"&gt;experiment with this sample build scan project&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now let’s go through some examples of adding custom data into your build scans (see the user manual for &lt;a href="https://docs.gradle.com/scans/#extending_build_scans"&gt;additional examples&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id="tags"&gt;Tags&lt;/h2&gt;

&lt;p&gt;Let’s start with the simplest type of custom data: tags. Tags are a way to add simple pieces of metadata to your build scan. You can use tags to add context to your build, such as whether the build was run locally or on a CI server, whether the build had any local changes, the error type of a failing build, etc. Here is an &lt;a href="https://scans.gradle.com/s/iodpryfwszmby"&gt;example build scan&lt;/a&gt; that tags the build as having:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;run on CI&lt;/li&gt;
  &lt;li&gt;come from the master branch&lt;/li&gt;
  &lt;li&gt;included local code changes (“dirty”)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, to attach a tag showing whether the build ran locally or on a CI server, you can add the following to its build script:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getenv&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"CI"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;buildScan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tag&lt;/span&gt; &lt;span class="s2"&gt;"CI"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;buildScan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tag&lt;/span&gt; &lt;span class="s2"&gt;"LOCAL"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The tag is then displayed under the project name when viewing the build scan:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/build-scan-ui-tag.png" alt="Build scan tag" /&gt;&lt;/p&gt;

&lt;h2 id="links"&gt;Links&lt;/h2&gt;

&lt;p&gt;In addition to tags, you can include links that readers of your build scan might find useful. For example, you could include a convenient link to the project source on GitHub or a link to the CI results of the Gradle build. This &lt;a href="https://scans.gradle.com/s/gtoxe7hyq3bl6"&gt;example build scan&lt;/a&gt; demonstrates what such links look like.&lt;/p&gt;

&lt;p&gt;Let’s say your CI tool makes the build results URL available as an environment variable. You could grab that value and add it as a custom link by using the following code in your build script:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getenv&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"CI"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;buildScan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;link&lt;/span&gt; &lt;span class="s2"&gt;"CI build"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getenv&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"BUILD_URL"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You also have the flexibility to add a link to the current revision or commit of the project’s source code. The following example links the build scan to its corresponding commit on GitHub (as long as the Git command line tools are available):&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;commitId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'git rev-parse --verify HEAD'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;execute&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;buildScan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;link&lt;/span&gt; &lt;span class="s2"&gt;"Source"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"https://github.com/gradle/gradle-build-scan-quickstart/tree/"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;commitId&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Links are displayed in the top section when viewing the build scan:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/build-scan-ui-links.png" alt="Build scan links" /&gt;&lt;/p&gt;

&lt;h2 id="custom-values"&gt;Custom values&lt;/h2&gt;

&lt;p&gt;Custom values can be used to make &lt;em&gt;any&lt;/em&gt; information part of the build scan. In &lt;a href="https://scans.gradle.com/s/nadne7cvexins#custom-values"&gt;this example build scan&lt;/a&gt;, you can see the corresponding CI build date, CI build number and the name of the Git branch as custom values. These values are available when viewing the build scan or when searching for build scans in &lt;a href="https://gradle.com/enterprise"&gt;Gradle Enterprise&lt;/a&gt;. Let’s go through a couple of examples showing how you can add custom values to your build scan.&lt;/p&gt;

&lt;p&gt;In our first example, we assume your CI tool injects build information into the build via environment variables. You could then use the following code in your build script to attach the build number and date to the build scan:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getenv&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"CI"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;buildScan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;value&lt;/span&gt; &lt;span class="s2"&gt;"CI build number"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getenv&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"BUILD_NUMBER"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;buildScan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;value&lt;/span&gt; &lt;span class="s2"&gt;"CI build date"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getenv&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"BUILD_DATE"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since we are setting these custom values from inside a Gradle build script, you have the power to do things like run external commands to capture more information about the project status. For example, you could add the current Git branch of the build by running a Git command and setting a custom value with the result:&lt;/p&gt;

&lt;div class="language-groovy highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;branchName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'git rev-parse --abbrev-ref HEAD'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;execute&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;buildScan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;value&lt;/span&gt; &lt;span class="s2"&gt;"Git branch"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;branchName&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The custom values are displayed on the main page when viewing the build scan:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/build-scan-ui-values.png" alt="Build scan custom values" /&gt;&lt;/p&gt;

&lt;h2 id="command-line"&gt;Command line&lt;/h2&gt;

&lt;p&gt;To give you greater flexibility in how you pass custom data to your build scan, you can also specify tags, links, and custom values on the command line. For example, you can quickly attach ad-hoc information to your build scan in order to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;help debug a specific local build failure&lt;/li&gt;
  &lt;li&gt;tag an experimental build&lt;/li&gt;
  &lt;li&gt;add CI-specific custom data without modifying your build script&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You do this by specifying system properties with the appropriate names, as demonstrated by these examples:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;$ gradle build -Dscan.tag.EXPERIMENTAL

$ gradle build -Dscan.link.buildUrl=$CI_BUILD_URL

$ gradle build -Dscan.value.buildNumber=$CI_BUILD_NUMBER
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first adds a tag named “EXPERIMENTAL”, the second adds a link titled “buildUrl”, and the third adds a custom value called “buildNumber”.&lt;/p&gt;

&lt;h2 id="searching-based-on-custom-data"&gt;Searching based on custom data&lt;/h2&gt;

&lt;p&gt;When using build scans on-premises with &lt;a href="https://gradle.com/enterprise"&gt;Gradle Enterprise&lt;/a&gt;, you can search for build scans based on custom data such as tags and custom values. For example, you can search for all builds that ran on CI against the master branch using the terms shown in this screenshot:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/build-scan-ui-search-results.png" alt="Build scan serch results" /&gt;&lt;/p&gt;

&lt;h2 id="live-demo"&gt;Live Demo&lt;/h2&gt;

&lt;p&gt;For a live demo of adding custom data with even more examples, check out this recent talk by Luke Daley and Etienne Studer at the Bay Area Gradle Users meetup. The video starts with an overview of build scans and dives into the details of adding custom data around the 22:30 mark.&lt;/p&gt;

&lt;iframe class="fullwidth" width="640" height="360" src="https://www.youtube.com/embed/1-rjqhLcyYM" frameborder="0" allowfullscreen=""&gt;&lt;/iframe&gt;

&lt;p&gt;Adding custom data to your build scans gives you the power and flexibility to augment your build scans with tags, links, or other data tailored to your team’s specific needs. Then you have even more information available to easily share with your teammates in a build scan—reducing the guesswork of diagnosing build failures. Happy scanning!&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Save the Date: Free Gradle Training in January</title>
    <link href="https://blog.gradle.org/january-free-training"/>
    <updated>2016-12-08T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/january-free-training</id>
    <author>
      <name>Schalk W. Cronjé</name>
    </author>
    <content type="html">
      &lt;p&gt;Getting started with a new technology can be daunting. Learning the basics by reading manuals and blog posts and searching forums can be time-consuming. And getting a whole team up to speed is a challenge all its own. That’s why for years now, we’ve offered a range of Gradle training courses to help teams fast-track the process of learning and mastering Gradle.&lt;/p&gt;

&lt;p&gt;Our flagship &lt;em&gt;Introduction to Gradle&lt;/em&gt; course has always been our most popular, and in October we ran an experiment with it: we gave it away for free. That’s a steep discount from the usual price of $900 per seat, but we wanted to see just how many people we could help to learn Gradle if cost were not a factor.&lt;/p&gt;

&lt;p&gt;We’re happy to report that this first free training was an overwhelming success, and are even happier to announce that we’ll offer a second free Introduction to Gradle training on January 11th and 12th. The course will be led by Gradle veterans &lt;a href="https://github.com/ghale"&gt;Gary Hale&lt;/a&gt; and &lt;a href="https://github.com/bmuschko"&gt;Ben Muschko&lt;/a&gt; over these two consecutive, 4-hour training days.&lt;/p&gt;

&lt;p&gt;In it, you and your colleagues will get everything you need to start creating and running your own Gradle builds with confidence. There will be plenty of hands-on labs and opportunies for Q&amp;amp;A with the instructors. We look forward to seeing you there!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Details&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;When?&lt;/strong&gt; 8:30am–12:30am PST on January 11–12, 2017&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Where?&lt;/strong&gt; Online via Zoom webinar - &lt;a href="https://go.gradle.com/free-training"&gt;Register Now&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

    </content>
  </entry>
  <entry>
    <title>November 15th Bay Area Gradle Users Meetup: Recap and Videos</title>
    <link href="https://blog.gradle.org/november-bay-area-meetup-recap"/>
    <updated>2016-11-22T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/november-bay-area-meetup-recap</id>
    <author>
      <name>Peter Ledbrook</name>
    </author>
    <content type="html">
      &lt;p&gt;We’d like to thank everyone that came along to our &lt;a href="/november-15th-bay-area-gradle-users-meetup"&gt;Bay Area Gradle Users meetup&lt;/a&gt; last week, and we’d like to thank LinkedIn once again for hosting us—it was a great event! For those who were unable to attend for reasons of distance, time or anything else, we filmed both sessions and are delighted to make the videos available to everyone.&lt;/p&gt;

&lt;p&gt;As described in that earlier blog post, Szczepan Faber and Hans Dockter talked in detail about Gradle’s new composite build feature:&lt;/p&gt;

&lt;iframe class="fullwidth" width="640" height="360" src="https://www.youtube.com/embed/krv317ZOWGg" frameborder="0" allowfullscreen=""&gt;&lt;/iframe&gt;

&lt;p&gt;In particular, Szczepan demonstrated the potential for working with multi-repository projects in an IDE as if they were part of the same multi-project build. You’ll find that in the first 10 minutes of the video.&lt;/p&gt;

&lt;p&gt;That talk was followed by Luke Daley and Etienne Studer presenting the advantages of using custom data in your build scans:&lt;/p&gt;

&lt;iframe class="fullwidth" width="640" height="360" src="https://www.youtube.com/embed/1-rjqhLcyYM" frameborder="0" allowfullscreen=""&gt;&lt;/iframe&gt;

&lt;p&gt;It’s well worth setting aside some time to watch both of these if you can.&lt;/p&gt;

&lt;p&gt;We hope you find these videos useful and we look forward to seeing many of you at the next meetup!&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Webinar: Customizing Build Scan Data</title>
    <link href="https://blog.gradle.org/webinar-customizing-build-scan-data"/>
    <updated>2016-11-02T12:00:00+00:00</updated>
    <id>https://blog.gradle.org/webinar-customizing-build-scan-data</id>
    <author>
      <name>Peter Ledbrook</name>
    </author>
    <content type="html">
      &lt;p&gt;For those of you who can’t make our &lt;a href="/november-15th-bay-area-gradle-users-meetup"&gt;Bay Area meetup on November 15th&lt;/a&gt;, we’re putting on a webinar a couple days later that will cover one of the same topics: &lt;em&gt;customizing build scan data&lt;/em&gt;. Even better, the webinar will be delivered by one of Gradle’s best: &lt;a href="https://github.com/mark-vieira"&gt;Mark Vieira&lt;/a&gt;! So come join us for a half-hour of valuable learning and discover how to maximize the benefit of your build scans.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Details&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;When?&lt;/strong&gt; 11:00 - 11:30am PT on November 17, 2016&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Where?&lt;/strong&gt; Online via Zoom webinar - &lt;a href="https://go.gradle.com/november-webinar/"&gt;Register Now&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There will be an opportunity for Q&amp;amp;A and a recording of the webinar will be made available to attendees. We hope you’ll join us!&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>November 15th Bay Area Gradle Users Meetup</title>
    <link href="https://blog.gradle.org/november-15th-bay-area-gradle-users-meetup"/>
    <updated>2016-11-02T11:00:00+00:00</updated>
    <id>https://blog.gradle.org/november-15th-bay-area-gradle-users-meetup</id>
    <author>
      <name>Peter Ledbrook</name>
    </author>
    <content type="html">
      &lt;p&gt;Everyone has an opportunity to engage with the Gradle team online through a variety of channels, but nothing beats meeting people face to face. If you are around the Silicon Valley area on November 15th, you can meet three of the team at the &lt;a href="http://www.meetup.com/Bay-Area-Gradle-Users"&gt;Bay Area Gradle Users&lt;/a&gt; meetup along with an expert user and build master from LinkedIn.&lt;/p&gt;

&lt;p&gt;We have two great talks lined up, the first of which introduces you to an exciting new feature within Gradle—composite builds—while the second shows you how to get more out of your build scans with custom data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Details:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Who?&lt;/strong&gt; Hans Dockter, Szczepan Faber (LinkedIn), Luke Daley, Etienne Studer&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;When?&lt;/strong&gt; 6:00pm PT on November 15, 2016&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Where?&lt;/strong&gt; LinkedIn, 605 W. Maude, Sunnyvale, CA&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RSVP&lt;/strong&gt;: If you plan to attend, please &lt;a href="https://www.eventbrite.com/e/bay-area-gradle-users-meetup-tickets-29087446335"&gt;register beforehand via Eventbrite&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We hope to see you there!&lt;/p&gt;

&lt;h2 id="hans-dockter-and-szczepan-faber-on-composite-builds"&gt;Hans Dockter and Szczepan Faber on Composite Builds&lt;/h2&gt;

&lt;p&gt;Many of you will be familiar with Gradle’s multi-project build support which allows you set up dependencies between projects, e.g. where the output of one project—say, a JAR file—is required by another. But this only works if the projects are part of the same multi-project build.&lt;/p&gt;

&lt;p&gt;In this talk, Hans and Szczepan will explain how Gradle’s new support for &lt;a href="/introducing-composite-builds"&gt;composite builds&lt;/a&gt; extends this behavior to projects that are otherwise independent of one another. Want to test a local fix to a library one of your projects depends on? Now you can—without having to publish a new version of that library. Composite builds also enable structuring your projects in new ways, since you no longer need to keep all projects in one repository or directory hierarchy.&lt;/p&gt;

&lt;p&gt;Hans won’t just talk about the topic, he’ll also show you how the feature works in practice. You’ll come away with a firm understanding of the value of composite builds and how you might put them to use in your own projects.&lt;/p&gt;

&lt;h2 id="luke-daley-and-etienne-studer-on-customizing-build-scan-data"&gt;Luke Daley and Etienne Studer on Customizing Build Scan Data&lt;/h2&gt;

&lt;p&gt;&lt;a href="/introducing-build-scans"&gt;Build scans&lt;/a&gt; already provide deep insights into your build by reporting key metrics and data. These are incredibly useful on their own, but Gradle is designed around the understanding that no two builds are the same. That’s why build scans allow you to add custom tags, links, and values from your builds. These custom annotations can help you bring out insights that are very specific to your build and to the environment in which your build is run.&lt;/p&gt;

&lt;p&gt;In this talk, Luke and Etienne will show examples of how you can use this feature to add extra value to your build scans. The aim is to sow the seeds of inspiration for your own builds using a feature that you might otherwise overlook.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>The Road to Gradle Script Kotlin 1.0</title>
    <link href="https://blog.gradle.org/kotlin-scripting-update"/>
    <updated>2016-10-26T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/kotlin-scripting-update</id>
    <author>
      <name>Rodrigo B. de Oliveira</name>
    </author>
    <content type="html">
      &lt;p&gt;Five months ago we &lt;a href="/kotlin-meets-gradle"&gt;announced the first pre-release of Gradle Script Kotlin&lt;/a&gt;, and we thought now would be a good time to review the progress we’ve made since. We have shipped eight additional pre-releases during that time, and the road to 1.0 is looking clearer every day. So let’s take a look at the ground we’ve covered so far and where we’re going from here, shall we?&lt;/p&gt;

&lt;h2 id="v010"&gt;v0.1.0&lt;/h2&gt;
&lt;p&gt;As you may recall, this is what our &lt;a href="https://github.com/gradle/gradle-script-kotlin/blob/cc14d3/samples/hello-world/build.gradle.kts"&gt;&lt;code class="highlighter-rouge"&gt;hello-world&lt;/code&gt; sample&lt;/a&gt; looked like at the time of our first release:&lt;/p&gt;

&lt;div class="language-kotlin highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.gradle.api.plugins.*&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.gradle.script.lang.kotlin.*&lt;/span&gt;

&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ApplicationPlugin&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;()&lt;/span&gt;

&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ApplicationPluginConvention&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;mainClassName&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"samples.HelloWorld"&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;repositories&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;jcenter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;dependencies&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;"testCompile"&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"junit:junit:4.12"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Oh, that annoying &lt;code class="highlighter-rouge"&gt;org.gradle.script.lang.kotlin.*&lt;/code&gt; import! The publicly condemned, IDE unfriendly, string-based &lt;code class="highlighter-rouge"&gt;"testCompile"&lt;/code&gt; dependency configuration! And of course—for those souls brave enough to have tried them—the infamous &lt;code class="highlighter-rouge"&gt;generateKtsConfig&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;patchIdeaConfig&lt;/code&gt; tasks required to get Kotlin-based build scripts working in IDEA. These were early days, no doubt, and they brought with them a few rough edges.&lt;/p&gt;

&lt;p&gt;But despite its flaws, the programming language and IDE experience in 0.1.0 was already so good it got us hooked. As for the rough edges, we could already see ways to smooth them out, which led to the release of &lt;a href="https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.2.0"&gt;0.2.0&lt;/a&gt; one month later.&lt;/p&gt;

&lt;h2 id="v020"&gt;v0.2.0&lt;/h2&gt;
&lt;p&gt;With &lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/33"&gt;implicit imports&lt;/a&gt; and a &lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/36"&gt;tooling-friendly alternative to string-based dependency configurations&lt;/a&gt;, &lt;code class="highlighter-rouge"&gt;hello-world&lt;/code&gt; 0.2.0 started looking clean and concise:&lt;/p&gt;

&lt;div class="language-kotlin highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ApplicationPlugin&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;()&lt;/span&gt;

&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ApplicationPluginConvention&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;mainClassName&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"samples.HelloWorld"&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;repositories&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;jcenter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;dependencies&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;testCompile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"junit:junit:4.12"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/26"&gt;Seamless project imports&lt;/a&gt; meant that Kotlin-based builds in IDEA started working out of the box, and the days of mistyping &lt;code class="highlighter-rouge"&gt;generateKtsConfig&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;patchIdeaConfig&lt;/code&gt; were no more.&lt;/p&gt;

&lt;p&gt;Perhaps most importantly, 0.2.0’s &lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/29"&gt;support for build script dependencies and external plugins&lt;/a&gt; made Gradle Script Kotlin a viable choice for many real-world projects.&lt;/p&gt;

&lt;h2 id="v030"&gt;v0.3.0&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.3.0"&gt;0.3.0&lt;/a&gt; was a major milestone for the project, as it was the first version to be included in a production Gradle distribution—&lt;a href="https://github.com/gradle/gradle/releases/tag/v3.0.0"&gt;Gradle 3.0&lt;/a&gt;, no less!&lt;/p&gt;

&lt;p&gt;And 0.3.0 was all about that &lt;a href="https://kotlin.link/"&gt;Kotlin&lt;/a&gt;! The &lt;a href="https://blog.jetbrains.com/kotlin/2016/07/first-glimpse-of-kotlin-1-1-coroutines-type-aliases-and-more/"&gt;new Kotlin 1.1-M01 compiler&lt;/a&gt;, support for &lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/84"&gt;Kotlin-based plugins&lt;/a&gt; and &lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/86"&gt;&lt;code class="highlighter-rouge"&gt;buildSrc&lt;/code&gt; directories&lt;/a&gt; plus some sugary &lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/103"&gt;Kotlin-Groovy interoperability&lt;/a&gt; primitives:&lt;/p&gt;

&lt;div class="language-kotlin highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;gradle&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;buildFinished&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;closureOf&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;BuildResult&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"$action finished"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// $action refers to BuildResult.getAction()
&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With Gradle 3.0 out the door, the #gradle channel of the public &lt;a href="http://kotlinslackin.herokuapp.com/"&gt;Kotlin Slack&lt;/a&gt; saw an increase in participation which helped us greatly in prioritizing the work that would come next.&lt;/p&gt;

&lt;h2 id="v031"&gt;v0.3.1&lt;/h2&gt;
&lt;p&gt;We noticed people struggling with the lack of a more type-safe and IDE-friendly way of configuring dependencies, so &lt;a href="https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.3.1"&gt;0.3.1&lt;/a&gt; came with a &lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/107"&gt;much-improved dependencies DSL&lt;/a&gt;:&lt;/p&gt;

&lt;div class="language-kotlin highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;dependencies&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"org.gradle"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"foo"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"1.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;isForce&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"org.gradle"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"bar"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;exclude&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"foo"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;runtime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"org.gradle:baz:1.0-SNAPSHOT"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;isChanging&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;
        &lt;span class="n"&gt;isTransitive&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;testCompile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"junit"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"junit"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;testRuntime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;":core"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;exclude&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"org.gradle"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/108"&gt;upgrade to Kotlin 1.1-dev-2053&lt;/a&gt; notably enhanced the performance of code assistance within IDEA and thanks to a &lt;a href="https://github.com/tyvsmith"&gt;valuable member of the community&lt;/a&gt; the first Gradle Script Kotlin &lt;a href="https://github.com/gradle/gradle-script-kotlin/tree/96b6fe/samples/hello-android"&gt;Android sample&lt;/a&gt; was published.&lt;/p&gt;

&lt;h2 id="v032"&gt;v0.3.2&lt;/h2&gt;
&lt;p&gt;With &lt;a href="https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.3.2"&gt;0.3.2&lt;/a&gt; we decided to tackle &lt;a href="https://www.youtube.com/watch?v=vv4zh_oPBTw&amp;amp;feature=youtu.be&amp;amp;t=1387"&gt;the dreaded &lt;code class="highlighter-rouge"&gt;it&lt;/code&gt; problem&lt;/a&gt; head-on via &lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/117"&gt;runtime code generation of Kotlin extensions&lt;/a&gt;. What is the dreaded &lt;code class="highlighter-rouge"&gt;it&lt;/code&gt; problem? Take the use of &lt;a href="https://docs.gradle.org/3.1/javadoc/org/gradle/api/Project.html#copySpec(org.gradle.api.Action)"&gt;&lt;code class="highlighter-rouge"&gt;copySpec&lt;/code&gt;&lt;/a&gt; as an example. Prior to 0.3.2, one would have written:&lt;/p&gt;

&lt;div class="language-kotlin highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;copySpec&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"src/data"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*.properties"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This syntax didn’t read very well, and was a departure from the fluid, readable DSL Gradle has long been known for. But never fear—with 0.3.2 &lt;code class="highlighter-rouge"&gt;it&lt;/code&gt; was gone:&lt;/p&gt;

&lt;div class="language-kotlin highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;copySpec&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"src/data"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*.properties"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id="v033-and-v040"&gt;v0.3.3 and v0.4.0&lt;/h2&gt;
&lt;p&gt;The recently-released versions &lt;a href="https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.3.3"&gt;0.3.3&lt;/a&gt; and &lt;a href="https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.4.0"&gt;0.4.0&lt;/a&gt; shipped the &lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/137"&gt;first&lt;/a&gt; of a series of improvements to &lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/112"&gt;multi-project builds&lt;/a&gt; including the ability to &lt;a href="https://github.com/gradle/gradle-script-kotlin/blob/7c74044cd84c4c426f1bca9af9f48bf332620c73/samples/multi-project-with-buildSrc/README.md"&gt;define custom build logic using Kotlin in &lt;code class="highlighter-rouge"&gt;buildSrc&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/gradle/gradle-script-kotlin/releases/tag/v0.4.0"&gt;0.4.0&lt;/a&gt; is available now and will ship with the forthcoming Gradle 3.2 distribution.&lt;/p&gt;

&lt;h2 id="toward-v100"&gt;Toward v1.0.0&lt;/h2&gt;
&lt;p&gt;What’s next, you ask? Here are some of the highlights of our upcoming releases in three key areas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/160"&gt;Performance&lt;/a&gt;: Faster project configuration via caching of compiled build scripts (&lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/31"&gt;#31&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/54"&gt;Usability&lt;/a&gt;: Type-safe accessors for extensions and conventions contributed by plugins (&lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/159"&gt;#159&lt;/a&gt;); Comprehensive
documentation (&lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/106"&gt;#106&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/30"&gt;Convenience&lt;/a&gt;: Declarative and tooling-friendly application of plugins, a.k.a., the &lt;code class="highlighter-rouge"&gt;plugins&lt;/code&gt; block (&lt;a href="https://github.com/gradle/gradle-script-kotlin/issues/168"&gt;#168&lt;/a&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Altogether, here’s how we envision the &lt;code class="highlighter-rouge"&gt;hello-world&lt;/code&gt; sample will look in Gradle Script Kotlin 1.0:&lt;/p&gt;

&lt;div class="language-kotlin highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;plugins&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;application&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;application&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;mainClassName&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"samples.HelloWorld"&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;repositories&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;jcenter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;dependencies&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;testCompile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"junit:junit:4.12"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;How does that look to you? We’d love to hear what you think.&lt;/p&gt;

&lt;p&gt;A big thanks to everyone that’s been along for the ride so far, and if you’re just getting started with Gradle Script Kotlin,  welcome!&lt;/p&gt;


    </content>
  </entry>
  <entry>
    <title>Now Open: GitHub Issues for Gradle</title>
    <link href="https://blog.gradle.org/github-issues"/>
    <updated>2016-10-19T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/github-issues</id>
    <author>
      <name>Eric Wendelin</name>
    </author>
    <content type="html">
      &lt;p&gt;Gradle has been an open-source project since its inception, but as a team we haven’t always lived up to the spirit of modern open-source collaboration. For example, we haven’t made it easy for folks to stay abreast of what we’re working on, and we haven’t had a clear and simple process for users to submit feature requests or bugs against a proper issue tracker.&lt;/p&gt;

&lt;p&gt;We’re very happy to announce that all of that is changing today. We’ve opened up GitHub Issues on the Gradle repository, and what follows are the immediate, medium-, and long-term changes we’re making to put—and keep!—the needs of the Gradle community front and center.&lt;/p&gt;

&lt;h2 id="effective-immediately"&gt;Effective Immediately&lt;/h2&gt;

&lt;p&gt;✔︎ You can now submit feature requests and bugs through &lt;a href="https://github.com/gradle/gradle/issues"&gt;GitHub Issues&lt;/a&gt;. We’ve put together a simple set of guidelines in the form of an &lt;a href="https://github.com/gradle/gradle/blob/master/.github/ISSUE_TEMPLATE.md"&gt;issue template&lt;/a&gt; so you’ll be presented with them each time you submit a new issue. We’ll label issues that don’t follow these guidelines as &lt;code class="highlighter-rouge"&gt;not-actionable&lt;/code&gt; and we’ll add a comment asking for what’s missing. To keep things clean, we’ll close these issues after a week of inactivity.&lt;/p&gt;

&lt;p&gt;✔︎ Actionable issues you submit will be prioritized alongside other Gradle improvements. Low-cost changes that benefit a large number of users are the easiest to justify, so please add a &lt;a href="https://github.com/blog/2119-add-reactions-to-pull-requests-issues-and-comments"&gt;👍  reaction&lt;/a&gt; to issues that matter to you. Like many other GitHub projects, we’ll use these reactions as a simple kind of voting system.&lt;/p&gt;

&lt;p&gt;✔︎ We’ll manage issue priority and workflow using &lt;a href="https://www.zenhub.io"&gt;ZenHub&lt;/a&gt;. If you’re not already familiar, ZenHub adds a number of features to GitHub Issues through its clever browser extension. It allows us to group related issues into &lt;a href="https://www.zenhub.com/blog/working-with-epics-in-github/"&gt;epics&lt;/a&gt; and to visualize everything via a kanban board. Installing and using ZenHub is by no means a requirement, but do check it out if you’d like to get an additional level of insight about what we’re working on.&lt;/p&gt;

&lt;p&gt;✔︎ Pull requests will be acknowledged within a week and reviews of them will be done through GitHub’s built-in &lt;a href="https://www.youtube.com/watch?v=HW0RPaJqm4g"&gt;pull request reviews&lt;/a&gt;. Please continue to follow the &lt;a href="https://github.com/gradle/gradle/blob/master/CONTRIBUTING.md"&gt;contribution guidelines&lt;/a&gt;—in a project as large and widely-used as Gradle, it’s crucial to be rigorous and get things right.&lt;/p&gt;

&lt;h2 id="medium-term-transition"&gt;Medium-Term Transition&lt;/h2&gt;

&lt;p&gt;Open &lt;a href="https://issues.gradle.org/"&gt;JIRA&lt;/a&gt; issues will be migrated to GitHub, and no new issues will be put into JIRA after the release of Gradle 3.2. We’ll ask for examples and/or clarification on JIRA issues that are not actionable so that they can be prioritized.&lt;/p&gt;

&lt;p&gt;To draw a clearer roadmap, we’ll add and maintain high-level feature &lt;a href="https://github.com/gradle/gradle/labels/epic"&gt;epics&lt;/a&gt; and mark them with milestones representing future Gradle releases.&lt;/p&gt;

&lt;p&gt;Our &lt;a href="https://discuss.gradle.org/c/bugs"&gt;bugs forum&lt;/a&gt; will no longer be necessary and will be made read-only. For general usage questions and potential bugs for which no reproducible test case or &lt;a href="/introducing-build-scans"&gt;build scan&lt;/a&gt; can be provided, please continue to use the &lt;a href="https://discuss.gradle.org/c/help-discuss"&gt;help/discuss forum&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="long-term-unity"&gt;Long-Term Unity&lt;/h2&gt;

&lt;p&gt;Once we’ve made the changes detailed above, we’ll continue looking for ways we can open up Gradle ecosystem to even greater community contribution. We’re really excited about this, and we hope you will be too.&lt;/p&gt;

&lt;p&gt;We’d love to hear your feedback—let us know what you think in the comments on this post or talk to us &lt;a href="https://twitter.com/gradle"&gt;@Gradle&lt;/a&gt; on Twitter. Your suggestions, questions, and of course, &lt;a href="https://github.com/gradle/gradle/issues"&gt;issues&lt;/a&gt; are most welcome.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Introducing Composite Builds</title>
    <link href="https://blog.gradle.org/introducing-composite-builds"/>
    <updated>2016-10-12T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/introducing-composite-builds</id>
    <author>
      <name>Stefan Oehme</name>
    </author>
    <content type="html">
      &lt;p&gt;It’s not every day that we get to announce a feature that revolutionizes several software engineering workflows, but today is that day. &lt;em&gt;&lt;a href="https://docs.gradle.org/current/userguide/composite_builds.html"&gt;Composite builds&lt;/a&gt;,&lt;/em&gt; a new feature in Gradle 3.1, enables an entirely new dimension in project organization.&lt;/p&gt;

&lt;p&gt;Composite builds are a way to &lt;em&gt;join multiple independent Gradle builds and build them together.&lt;/em&gt; The brevity of that statement does not fully convey all of the new possibilities, so let me show you how this will make your life as a developer a lot easier.&lt;/p&gt;

&lt;h2 id="joining-projects"&gt;Joining projects&lt;/h2&gt;
&lt;p&gt;Many organizations split their code base into several independent projects, each having a dedicated repository and release cycle. Integration between the projects is managed using binary dependencies, e.g. JAR files published to a binary repository like Artifactory. This approach has many advantages, but can be inefficient when trying to rapidly develop and test changes that affect two or more of these projects at once.&lt;/p&gt;

&lt;p&gt;Imagine for a moment that you are fixing a bug in a Java library that your application depends on. Your workflow probably looks something like the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Change the library&lt;/li&gt;
  &lt;li&gt;Publish the library to a local repository&lt;/li&gt;
  &lt;li&gt;Add the local repository to your application’s repositories&lt;/li&gt;
  &lt;li&gt;Change your application’s dependency to the new library version&lt;/li&gt;
  &lt;li&gt;Test your application&lt;/li&gt;
  &lt;li&gt;Repeat until the problem is fixed or you lose your mind&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With composite builds, you can short-circuit this workflow by &lt;em&gt;including the library’s build into your application’s build.&lt;/em&gt; Gradle will then automatically replace the &lt;em&gt;binary&lt;/em&gt; dependency on the library with a &lt;em&gt;project&lt;/em&gt; dependency—meaning that changes you make to the library become available to the application instantaneously:&lt;/p&gt;

&lt;p style="text-align: center;"&gt;&lt;script id="asciicast-9stxoe7vczhgkt0hhv6h6yk7e" src="https://asciinema.org/a/9stxoe7vczhgkt0hhv6h6yk7e.js" async="" type="text/javascript"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;The same approach works for plugins that your project depends on. You can now include a locally checked-out version of a plugin into your project’s build and get into the same kind of tight development loop between them:&lt;/p&gt;

&lt;p style="text-align: center;"&gt;&lt;script id="asciicast-cll4usx63ejj6aqocstebmp6q" src="https://asciinema.org/a/cll4usx63ejj6aqocstebmp6q.js" async="" type="text/javascript"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;The new &lt;code class="highlighter-rouge"&gt;includeBuild()&lt;/code&gt; API in &lt;code class="highlighter-rouge"&gt;settings.gradle&lt;/code&gt; even lets you write a Gradle build that dynamically includes other builds if they are available on the local file system. You could then import this composite into your IDE and do cross-repository refactoring or debugging.&lt;/p&gt;

&lt;h2 id="splitting-monoliths"&gt;Splitting Monoliths&lt;/h2&gt;
&lt;p&gt;Organizations that want to avoid the integration pains of multiple repositories tend to use a “monorepo”—a repository containing all projects, often including their dependencies and necessary tools. The upside is that all code is in one place and downstream breakages become visible immediately. But this convenience can come at the cost of productivity: a given developer will usually work only on a small part of a monorepo, but will still be forced to build all upstream projects, and that can mean a lot of waiting and wasted time. Likewise, importing large monorepo projects into an IDE often results in an unresponsive and overwhelming experience.&lt;/p&gt;

&lt;p&gt;With composite builds, you can break your monorepo up into several independent builds within the same repository. Developers can work with the individual builds to get fast turnarounds or work with the whole composite when they want to ensure that everything still plays well together:&lt;/p&gt;

&lt;p style="text-align: center;"&gt;&lt;script id="asciicast-6ze8hrt11ldevgonbue1sew3i" src="https://asciinema.org/a/6ze8hrt11ldevgonbue1sew3i.js" async="" type="text/javascript"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;If you’re planning to move from a monolithic application to multiple independent ones, composite builds now offer a seamless migration strategy.&lt;/p&gt;

&lt;h2 id="this-is-just-the-beginning"&gt;This is just the beginning&lt;/h2&gt;
&lt;p&gt;We plan to add a number of improvements to composite builds in upcoming releases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Targeting tasks in an included build from the command line&lt;/li&gt;
  &lt;li&gt;Richer dependency substitution API with support for custom publications&lt;/li&gt;
  &lt;li&gt;Executing included builds in parallel&lt;/li&gt;
  &lt;li&gt;Integration with Gradle’s &lt;a href="https://docs.gradle.org/3.1/userguide/continuous_build.html"&gt;continuous build&lt;/a&gt; capabilities&lt;/li&gt;
  &lt;li&gt;Out of the box support for composite builds in IntelliJ and Eclipse&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course, nothing is more important than feedback from real world usage. So please give composite builds a try in your own projects or have a look at the &lt;a href="https://github.com/gradle/gradle/tree/v3.1.0/subprojects/docs/src/samples/compositeBuilds"&gt;samples&lt;/a&gt;. Let us know about any problems, suggestions and cool things you built with it on the &lt;a href="https://discuss.gradle.org"&gt;Gradle Forum&lt;/a&gt;.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Introducing Build Scans</title>
    <link href="https://blog.gradle.org/introducing-build-scans"/>
    <updated>2016-10-06T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/introducing-build-scans</id>
    <author>
      <name>Chris Beams</name>
    </author>
    <content type="html">
      &lt;p&gt;A few months ago at this year’s Gradle Summit conference, we announced a new part of the Gradle platform called &lt;a href="https://www.youtube.com/watch?v=8IYA33e4_yk"&gt;&lt;em&gt;Gradle Cloud Services&lt;/em&gt;&lt;/a&gt;. In this post, I want to introduce you to the first of these services—the &lt;em&gt;Gradle Build Scan Service&lt;/em&gt;—and the &lt;em&gt;build scans&lt;/em&gt; it makes possible.&lt;/p&gt;

&lt;h2 id="what-is-a-build-scan"&gt;What is a build scan?&lt;/h2&gt;

&lt;p&gt;A build scan is a representation of data captured as you run your build. The &lt;a href="https://plugins.gradle.org/plugin/com.gradle.build-scan"&gt;Build Scan Plugin&lt;/a&gt; does the work of capturing the data and sending it to the Build Scan Service. The service then transforms the data into &lt;em&gt;information&lt;/em&gt; you can use and share with others. Here’s a quick example of using a build scan to investigate a failure:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://blog.gradle.org/images/build-scan.gif" alt="Publishing and Viewing a Build Scan" /&gt;&lt;/p&gt;

&lt;p&gt;It’s all about that link! Here—click it for yourself: &lt;a href="https://gradle.com/s/a5e3ngolykv3w"&gt;https://gradle.com/s/a5e3ngolykv3w&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As you can see, the information that scans provide can be a big help when troubleshooting, collaborating on, or optimizing the performance of your builds. For example, with a build scan in the mix, it’s no longer necessary to copy and paste error messages or include all the details about your environment each time you want to ask a question on Stack Overflow or the Gradle Forum. Instead, just include a link to your latest build scan. It contains much, if not all, of the information the person answering your question might need to know. It’ll save you both time, and they’ll probably thank you for it.&lt;/p&gt;

&lt;h2 id="whos-using-them"&gt;Who’s using them?&lt;/h2&gt;

&lt;p&gt;We’re excited that a number of prominent open source projects like Hibernate and JUnit 5 have &lt;a href="https://github.com/hibernate/hibernate-orm/commit/e3bee9e"&gt;already&lt;/a&gt; &lt;a href="https://github.com/junit-team/junit5#gradle-build-scans"&gt;integrated&lt;/a&gt; build scans into their workflow. You can take a look through sample scans from each of these projects at &lt;a href="https://gradle.com/#explore"&gt;gradle.com/explore&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://gradle.com/#explore"&gt;&lt;img src="https://blog.gradle.org/images/explore-build-scans.jpg" alt="Open Source Gradle Build Scans" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="put-build-scans-to-use-for-yourself"&gt;Put build scans to use for yourself&lt;/h2&gt;

&lt;p&gt;If you’re new to build scans, now is a great time to start using them. We’re continually rolling out new features, and we’ll cover each of them in subsequent posts. In the meantime, you can learn how to enable build scans for your existing projects via our &lt;a href="https://scans.gradle.com/get-started"&gt;getting started instructions&lt;/a&gt;, or get up and running with a sample project by cloning our &lt;a href="https://github.com/gradle/gradle-build-scan-quickstart"&gt;quick start repository&lt;/a&gt; and following the steps in its README.&lt;/p&gt;

&lt;p&gt;Happy scanning, and we look forward to your feedback!&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Hello, Again</title>
    <link href="https://blog.gradle.org/hello-again"/>
    <updated>2016-09-26T00:00:00+00:00</updated>
    <id>https://blog.gradle.org/hello-again</id>
    <author>
      <name>Chris Beams</name>
    </author>
    <content type="html">
      &lt;p&gt;Welcome to the new Gradle blog. On behalf of the whole team, it’s my pleasure to write this first post and share a bit about what we’re up to.&lt;/p&gt;

&lt;p&gt;Mainly, we’re putting together this new blog because we want to make sure users find out about the most important developments in Gradle-land. Our team has grown rapidly over the last couple years, and as a result we’ve shipped many new features and improvements. All too often, though, we find that would-be users never hear about them. This recent tweet provides a perfect example:&lt;/p&gt;

&lt;blockquote class="twitter-tweet" data-lang="en"&gt;&lt;p lang="en" dir="ltr"&gt;I read news, I try to keep up-to-date. So how did I miss that &lt;a href="https://twitter.com/gradle"&gt;@gradle&lt;/a&gt; can build &lt;a href="https://twitter.com/playframework"&gt;@playframework&lt;/a&gt;? Gotta look into this.&lt;/p&gt;&amp;mdash; Cristian Duicu (@cduicu) &lt;a href="https://twitter.com/cduicu/status/779301788654723072"&gt;September 23, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;

&lt;p&gt;Cristian’s question is a fair one. We first shipped Play support over a year ago; we mentioned it in our Gradle 2.6 &lt;a href="https://discuss.gradle.org/t/gradle-2-6-released/11092"&gt;forum announcement&lt;/a&gt; and &lt;a href="https://docs.gradle.org/2.6/release-notes"&gt;release notes&lt;/a&gt;, and we wrote &lt;a href="https://docs.gradle.org/3.1/userguide/play_plugin.html"&gt;a chapter about it&lt;/a&gt; in our user manual. Still, Cristian—and probably many others—missed it. How is that?&lt;/p&gt;

&lt;p&gt;The answer is pretty straightforward. Forum announcements and release notes are useful documents, but they get buried as new releases pile up. Reference documentation is important too, but our user manual has grown large, meaning that &lt;em&gt;Chapter 70: Building Play Applications&lt;/em&gt; is easy to miss if you’re not already looking for it.&lt;/p&gt;

&lt;p&gt;This situation isn’t surprising, nor is it unique to Gradle. As any project grows, it becomes a challenge to communicate about it effectively. In any case, we can no longer expect every current and future Gradle user to dig through past release notes or to read our user manual cover to cover simply to discover what Gradle can do. It’s on us to find better ways to get the word out.&lt;/p&gt;

&lt;p&gt;And that’s where this new blog comes in. We’ll post here whenever there’s something new in Gradle that we don’t want you to miss. We’ll keep it focused on things we think are important and worth your time. We hope it’ll become a trusted resource—not only for you to stay up to date with Gradle, but also for us to get feedback through your comments.&lt;/p&gt;

&lt;p&gt;A better blog isn’t a silver bullet, but we think it’s a great place to start. Indeed, it’s just the first step in a much larger effort to make working with and learning about Gradle as easy and enjoyable as possible. In the weeks to come you’ll see further improvements, including new guides and tutorials, a new gradle.org website, and a simpler process for filing bugs and feature requests.&lt;/p&gt;

&lt;p&gt;Naturally, we’ll announce each of these changes here on the blog. To stay tuned, &lt;a href="https://feed.gradle.org/blog.atom"&gt;subscribe to the blog’s Atom feed&lt;/a&gt; or &lt;a href="https://twitter.com/intent/follow?screen_name=Gradle"&gt;follow @Gradle on Twitter&lt;/a&gt;, where we’ll link to new posts as we publish them.&lt;/p&gt;

    </content>
  </entry>
</feed>
